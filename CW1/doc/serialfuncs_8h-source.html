<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: serialfuncs.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>serialfuncs.h</h1><a href="serialfuncs_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00010 <span class="preprocessor">#ifndef _SERIALFUNCS_H</span>
00011 <span class="preprocessor"></span><span class="preprocessor">#define _SERIALFUNCS_H</span>
00012 <span class="preprocessor"></span>
00013 <span class="preprocessor">#include &lt;iostream&gt;</span>
00014 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00015 <span class="preprocessor">#include &lt;iterator&gt;</span>
00016 <span class="preprocessor">#include &lt;string&gt;</span>
00017 <span class="preprocessor">#include &lt;sstream&gt;</span>
00018 <span class="preprocessor">#include &lt;vector&gt;</span>
00019 <span class="preprocessor">#include &lt;map&gt;</span>
00020 
00021 <span class="keyword">namespace </span>BEAST {
00022 
00032 std::string <a class="code" href="namespaceBEAST.html#a96">add_slashes</a>(<span class="keyword">const</span> std::string&amp; str);
00033 std::string <a class="code" href="namespaceBEAST.html#a97">strip_slashes</a>(<span class="keyword">const</span> std::string&amp; str);
00034 
<a name="l00036"></a><a class="code" href="group__serialisation.html#a17">00036</a> <span class="keyword">enum</span> <a class="code" href="group__serialisation.html#a17">SerialErrorType</a> {
00037     <a class="code" href="group__serialisation.html#a17a65">SERIAL_ERROR_UNKNOWN</a>,       
00038     <a class="code" href="group__serialisation.html#a17a66">SERIAL_ERROR_BAD_FILE</a>,      
00039     <a class="code" href="group__serialisation.html#a17a67">SERIAL_ERROR_WRONG_TYPE</a>,    
00040     <a class="code" href="group__serialisation.html#a17a68">SERIAL_ERROR_UNKNOWN_TYPE</a>,  
00041     <a class="code" href="group__serialisation.html#a17a69">SERIAL_ERROR_DATA_MISMATCH</a>  
00042 };
00043 
<a name="l00051"></a><a class="code" href="structBEAST_1_1SerialException.html">00051</a> <span class="keyword">struct </span><a class="code" href="structBEAST_1_1SerialException.html">SerialException</a>
00052 {
00053     <a class="code" href="structBEAST_1_1SerialException.html">SerialException</a>(<a class="code" href="group__serialisation.html#a17">SerialErrorType</a> e, std::string n = <span class="stringliteral">""</span>, std::string msg = <span class="stringliteral">""</span>):
00054         error(e), name(n), message(msg){}
00055 
00056     std::string     <a class="code" href="structBEAST_1_1SerialException.html#a1">ToString</a>()<span class="keyword">const</span>;
00057 
00058     <a class="code" href="group__serialisation.html#a17">SerialErrorType</a> error;
00059     std::string     name;
00060     std::string     message;
00061 };
00062 
00069 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Iterator&gt;
<a name="l00070"></a><a class="code" href="structBEAST_1_1extractor.html">00070</a> <span class="keyword">struct </span><a class="code" href="structBEAST_1_1extractor.html">extractor</a>
00071 {
00072     <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type _ValueType;
00073     <a class="code" href="structBEAST_1_1extractor.html">extractor</a>(_Iterator&amp; Iter):iter(Iter){}
00074     _ValueType operator()()
00075     {
00076         tempVal = *iter;
00077         ++iter;
00078         <span class="keywordflow">return</span> tempVal;
00079     }
00080     _Iterator iter;
00081     _ValueType tempVal;
00082 };
00083 
00094 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Iterator&gt;
<a name="l00095"></a><a class="code" href="group__serialisation.html#a2">00095</a> extractor&lt;_Iterator&gt; <a class="code" href="group__serialisation.html#a2">extract</a>(_Iterator&amp; Iter)
00096 {
00097     <span class="keywordflow">return</span> extractor&lt;_Iterator&gt;(Iter);
00098 }
00099 
00111 <span class="keyword">template</span>&lt;<span class="keyword">class</span> _InIt, <span class="keyword">class</span> _OutIt&gt;
<a name="l00112"></a><a class="code" href="group__serialisation.html#a3">00112</a> _InIt <a class="code" href="group__serialisation.html#a3">copy_from</a>(_OutIt _First, _OutIt _Last, _InIt _Src)
00113 {   <span class="comment">// copy [_First, _Last) from [_Src, ...)</span>
00114     <span class="keywordflow">for</span> (; _First != _Last; ++_Src, ++_First)
00115         *_First = *_Src;
00116     <span class="keywordflow">return</span> (_Src);
00117 }
00118 
00126 <span class="keyword">template</span>&lt;<span class="keyword">class</span> _OutIt&gt;
<a name="l00127"></a><a class="code" href="group__serialisation.html#a4">00127</a> std::istream&amp; <a class="code" href="group__serialisation.html#a4">copy_from_istream</a>(_OutIt _First, _OutIt _Last, std::istream&amp; in)
00128 {   <span class="comment">// copy [_First, _Last) from in</span>
00129     <span class="keywordflow">for</span> (; _First != _Last; ++_First)
00130         in &gt;&gt; *_First;
00131     <span class="keywordflow">return</span> in;
00132 }
00133 
<a name="l00141"></a><a class="code" href="structBEAST_1_1switcher.html">00141</a> <span class="keyword">struct </span><a class="code" href="structBEAST_1_1switcher.html">switcher</a>
00142 {
00143     <a class="code" href="structBEAST_1_1switcher.html">switcher</a>(std::string s, <span class="keywordtype">bool</span>&amp; b):name(s),option(b){}
00144     std::string name;
00145     <span class="keywordtype">bool</span>&amp; option;
00146 };
00147 
<a name="l00153"></a><a class="code" href="group__serialisation.html#a5">00153</a> <span class="keyword">inline</span> std::istream&amp; <a class="code" href="group__biosystems.html#a3">operator&gt;&gt;</a>(std::istream&amp; in, switcher s)
00154 {
00155     std::string compare;
00156     in &gt;&gt; compare;
00157     s.option = (compare == s.name);
00158     <span class="keywordflow">return</span> in;
00159 }
00160 
00166 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> _Ax&gt;
<a name="l00167"></a><a class="code" href="group__serialisation.html#a6">00167</a> <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const std::vector&lt;_Ty, _Ax&gt;&amp; v)
00168 {
00169     out &lt;&lt; <span class="stringliteral">"vector "</span>
00170         &lt;&lt; static_cast&lt;int&gt;(v.size()) &lt;&lt; <span class="stringliteral">" "</span>;
00171     std::copy(v.begin(), v.end(), std::ostream_iterator&lt;_Ty&gt;(out, <span class="stringliteral">" "</span>));
00172     <span class="keywordflow">return</span> out;
00173 }
00174 
00179 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> _Ax&gt;
<a name="l00180"></a><a class="code" href="group__serialisation.html#a7">00180</a> <span class="keyword">inline</span> std::istream&amp; <a class="code" href="group__biosystems.html#a3">operator&gt;&gt;</a>(std::istream&amp; in, std::vector&lt;_Ty, _Ax&gt;&amp; v)
00181 {
00182     std::string name;
00183     in &gt;&gt; name;
00184     <span class="keywordflow">if</span> (name != <span class="stringliteral">"vector"</span>) {
00185         <span class="keywordflow">throw</span> SerialException(<a class="code" href="group__serialisation.html#a17a69">SERIAL_ERROR_DATA_MISMATCH</a>, <span class="stringliteral">""</span>, 
00186                               <span class="stringliteral">"Expected vector but got "</span> + name);
00187     }
00188     <span class="keywordtype">int</span> size;
00189     in &gt;&gt; size;
00190     v.resize(size);
00191     <a class="code" href="group__serialisation.html#a4">copy_from_istream</a>(v.begin(), v.end(), in);
00192     <span class="keywordflow">return</span> in;
00193 }
00194 
00200 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> _Pr, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00201"></a><a class="code" href="group__serialisation.html#a8">00201</a> <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const std::map&lt;std::string, _Ty, _Pr, _Alloc&gt;&amp; m)
00202 {
00203     <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00204 
00205     out &lt;&lt; <span class="stringliteral">"map_string "</span>
00206         &lt;&lt; static_cast&lt;int&gt;(m.size()) &lt;&lt; <span class="stringliteral">"\n"</span>;
00207     <span class="keyword">typename</span> map&lt;string, _Ty, _Pr, _Alloc&gt;::const_iterator i = m.begin();
00208 
00209     <span class="keywordflow">for</span> (; i != m.end(); ++i) {
00210         out &lt;&lt; <a class="code" href="namespaceBEAST.html#a96">add_slashes</a>(i-&gt;first) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;second &lt;&lt; <span class="stringliteral">"\n"</span>;
00211     }
00212 
00213     <span class="keywordflow">return</span> out;
00214 }
00215 
00220 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> _Pr, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00221"></a><a class="code" href="group__serialisation.html#a9">00221</a> <span class="keyword">inline</span> std::istream&amp; <a class="code" href="group__biosystems.html#a3">operator&gt;&gt;</a>(std::istream&amp; in, <span class="keyword">const</span> std::map&lt;std::string, _Ty, _Pr, _Alloc&gt;&amp; m)
00222 {
00223     <span class="keywordtype">int</span> size;
00224     std::string name;
00225     _Ty val;
00226 
00227     in &gt;&gt; name;
00228     <span class="keywordflow">if</span> (name != <span class="stringliteral">"map_string"</span>) {
00229         <span class="keywordflow">throw</span> SerialException(<a class="code" href="group__serialisation.html#a17a69">SERIAL_ERROR_DATA_MISMATCH</a>, <span class="stringliteral">""</span>, 
00230                               <span class="stringliteral">"Expected map_string but got "</span> + name);
00231     }
00232 
00233     in &gt;&gt; size;
00234     m.clear();
00235 
00236     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; size; ++i) {
00237         in &gt;&gt; name &gt;&gt; val;
00238         m[<a class="code" href="namespaceBEAST.html#a97">strip_slashes</a>(name)] = val;
00239     }
00240 
00241     <span class="keywordflow">return</span> in;
00242 }
00243 
00249 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Kty, <span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> _Pr, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00250"></a><a class="code" href="group__serialisation.html#a10">00250</a> <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const std::map&lt;_Kty, _Ty, _Pr, _Alloc&gt;&amp; m)
00251 {
00252     out &lt;&lt; <span class="stringliteral">"map "</span>
00253         &lt;&lt; static_cast&lt;int&gt;(m.size()) &lt;&lt; endl;
00254     <span class="keyword">typename</span> std::map&lt;_Kty, _Ty, _Pr, _Alloc&gt;::const_iterator i = m.begin();
00255 
00256     <span class="keywordflow">for</span> (; i != m.end(); ++i) {
00257         out &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;second &lt;&lt; std::endl;
00258     }
00259     <span class="keywordflow">return</span> out;
00260 }
00261 
00266 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Kty, <span class="keyword">typename</span> _Ty, <span class="keyword">typename</span> _Pr, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00267"></a><a class="code" href="group__serialisation.html#a11">00267</a> <span class="keyword">inline</span> std::istream&amp; <a class="code" href="group__biosystems.html#a3">operator&gt;&gt;</a>(std::istream&amp; in, std::map&lt;_Kty, _Ty, _Pr, _Alloc&gt;&amp; m)
00268 {
00269     std::string name;
00270     in &gt;&gt; name;
00271     <span class="keywordflow">if</span> (name != <span class="stringliteral">"map"</span>) {
00272         <span class="keywordflow">throw</span> SerialException(<a class="code" href="group__serialisation.html#a17a69">SERIAL_ERROR_DATA_MISMATCH</a>, <span class="stringliteral">""</span>, 
00273                               <span class="stringliteral">"Expected map but got "</span> + name);
00274     }
00275 
00276     <span class="keywordtype">int</span> size;
00277     _Kty key;
00278     _Ty val;
00279 
00280     in &gt;&gt; size;
00281     m.clear();
00282 
00283     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; size; ++i) {
00284         in &gt;&gt; key &gt;&gt; val;
00285         m[key] = val;
00286     }
00287 
00288     <span class="keywordflow">return</span> in;
00289 }
00290 
00296 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00297"></a><a class="code" href="group__serialisation.html#a12">00297</a> <span class="keyword">inline</span> T1&amp; <a class="code" href="group__serialisation.html#a12">stream_convert</a>(T2&amp; input)
00298 {
00299     <span class="keywordflow">return</span> *reinterpret_cast&lt;T1*&gt;(&amp;input);
00300 }
00301 
<a name="l00307"></a><a class="code" href="group__serialisation.html#a13">00307</a> <span class="preprocessor">#define IMPLEMENT_IOSTREAM_CAST(_Ty,_Cast)                  \</span>
00308 <span class="preprocessor">inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, _Ty&amp; i)  \</span>
00309 <span class="preprocessor">{                                                           \</span>
00310 <span class="preprocessor">    out &lt;&lt; static_cast&lt;_Cast&gt;(i);                           \</span>
00311 <span class="preprocessor">    return out;                                             \</span>
00312 <span class="preprocessor">}                                                           \</span>
00313 <span class="preprocessor">                                                            \</span>
00314 <span class="preprocessor">inline std::istream&amp; operator&gt;&gt;(std::istream&amp; in, _Ty&amp; i)   \</span>
00315 <span class="preprocessor">{                                                           \</span>
00316 <span class="preprocessor">    _Cast input;                                            \</span>
00317 <span class="preprocessor">    in &gt;&gt; input;                                            \</span>
00318 <span class="preprocessor">    i = static_cast&lt;_Ty&gt;(input);                            \</span>
00319 <span class="preprocessor">    return in;                                              \</span>
00320 <span class="preprocessor">}</span>
00321 <span class="preprocessor"></span>
<a name="l00332"></a><a class="code" href="group__serialisation.html#a14">00332</a> <span class="preprocessor">#define IMPLEMENT_IOSTREAM_BINARY_CONVERSION(_Ty)           \</span>
00333 <span class="preprocessor">inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, _Ty&amp; i)  \</span>
00334 <span class="preprocessor">{                                                           \</span>
00335 <span class="preprocessor">    out.write(reinterpret_cast&lt;char*&gt;(&amp;i), sizeof(i));      \</span>
00336 <span class="preprocessor">    return out;                                             \</span>
00337 <span class="preprocessor">}                                                           \</span>
00338 <span class="preprocessor">                                                            \</span>
00339 <span class="preprocessor">inline std::istream&amp; operator&gt;&gt;(std::istream&amp; in, _Ty&amp; i)   \</span>
00340 <span class="preprocessor">{                                                           \</span>
00341 <span class="preprocessor">    in.read(reinterpret_cast&lt;char*&gt;(&amp;i), sizeof(i));        \</span>
00342 <span class="preprocessor">    return in;                                              \</span>
00343 <span class="preprocessor">}</span>
00344 <span class="preprocessor"></span>
<a name="l00350"></a><a class="code" href="group__serialisation.html#a15">00350</a> <span class="preprocessor">#define IMPLEMENT_SERIALISATION(_Name, _Parent)                     \</span>
00351 <span class="preprocessor">public:                                                             \</span>
00352 <span class="preprocessor">    void Serialise(std::ostream&amp; out)const                          \</span>
00353 <span class="preprocessor">    {                                                               \</span>
00354 <span class="preprocessor">        out &lt;&lt; _Name &lt;&lt; "\n";                                       \</span>
00355 <span class="preprocessor">        _Parent::Serialise(out);                                    \</span>
00356 <span class="preprocessor">    }                                                               \</span>
00357 <span class="preprocessor">                                                                    \</span>
00358 <span class="preprocessor">    void Unserialise(std::istream&amp; in)                              \</span>
00359 <span class="preprocessor">    {                                                               \</span>
00360 <span class="preprocessor">        std::string name;                                           \</span>
00361 <span class="preprocessor">        in &gt;&gt; name;                                                 \</span>
00362 <span class="preprocessor">        if (name != _Name) {                                        \</span>
00363 <span class="preprocessor">            throw SerialException(SERIAL_ERROR_WRONG_TYPE, name,    \</span>
00364 <span class="preprocessor">                    std::string("This object is type ") + _Name);   \</span>
00365 <span class="preprocessor">        }                                                           \</span>
00366 <span class="preprocessor">        _Parent::Unserialise(in);                                   \</span>
00367 <span class="preprocessor">    }</span>
00368 <span class="preprocessor"></span>
00369 <span class="preprocessor">#define IMPLEMENT_LOADER(_Name, _Type) \</span>
00370 <span class="preprocessor">    Unserialiser::Instance().Add(_Name, new ObjLoader&lt;_Type&gt;());</span>
00371 <span class="preprocessor"></span>
00372 
00377 } <span class="comment">// namespace BEAST</span>
00378 
00379 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:25:35 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
