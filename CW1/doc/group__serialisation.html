<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: Serialisation Utilities</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Serialisation Utilities</h1>Currently, the simplest way to store data is by serialisation - simply saving and loading object data as unformatted text.  
<a href="#_details">More...</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1extractor.html">extractor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a function object which can be used for copying from an iterator when the number of input values is unknown. </em> <a href="structBEAST_1_1extractor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ObjLoader.html">ObjLoader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A functor for recreating templated object types using serialisation. </em> <a href="structBEAST_1_1ObjLoader.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ObjLoaderBase.html">ObjLoaderBase</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple abstract base class for <a class="el" href="structBEAST_1_1ObjLoader.html">ObjLoader</a> functors. </em> <a href="structBEAST_1_1ObjLoaderBase.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1SerialException.html">SerialException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Since exceptions have an undesirable overhead, they have not been used elsewhere in the simulation environment for reasons of speed. </em> <a href="structBEAST_1_1SerialException.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1switcher.html">switcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The switcher is useful when configuring bools from string data. </em> <a href="structBEAST_1_1switcher.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Unserialiser.html">Unserialiser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is available for unserialising objects from streams, without knowing which type of object is to be unserialised - the type is determined from the header of the stream. </em> <a href="classBEAST_1_1Unserialiser.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a13">IMPLEMENT_IOSTREAM_CAST</a>(_Ty, _Cast)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this macro to create a custom output operator which simply casts _Ty to the type specified by _Cast. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a14">IMPLEMENT_IOSTREAM_BINARY_CONVERSION</a>(_Ty)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This macro is intended as a quick solution to the problem of encoding structs and classes into output streams. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a15">IMPLEMENT_SERIALISATION</a>(_Name, _Parent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this macro to add basic serialisation functionality to your derived classes by simply serialising under a new name, but using the parent serialisation methods. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a16" doxytag="serialisation::IMPLEMENT_LOADER"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>IMPLEMENT_LOADER</b>(_Name, _Type)&nbsp;&nbsp;&nbsp;Unserialiser::Instance().Add(_Name, new ObjLoader&lt;_Type&gt;());</td></tr>

<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a17">SerialErrorType</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__serialisation.html#a17a65">SERIAL_ERROR_UNKNOWN</a>, 
<a class="el" href="group__serialisation.html#a17a66">SERIAL_ERROR_BAD_FILE</a>, 
<a class="el" href="group__serialisation.html#a17a67">SERIAL_ERROR_WRONG_TYPE</a>, 
<a class="el" href="group__serialisation.html#a17a68">SERIAL_ERROR_UNKNOWN_TYPE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__serialisation.html#a17a69">SERIAL_ERROR_DATA_MISMATCH</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerates the different types of errors encountered in serialisation. </em> <a href="#a17">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="serialisation::add_slashes"></a>
std::string&nbsp;</td><td class="memItemRight" valign=bottom><b>add_slashes</b> (const std::string &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="serialisation::strip_slashes"></a>
std::string&nbsp;</td><td class="memItemRight" valign=bottom><b>strip_slashes</b> (const std::string &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class _Iterator&gt; extractor&lt; _Iterator &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a2">extract</a> (_Iterator &amp;Iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs and returns an extractor of the correct type. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class _InIt, class _OutIt&gt; _InIt&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a3">copy_from</a> (_OutIt _First, _OutIt _Last, _InIt _Src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An algorithm similar to copy, but where the start and end of the target range is specified rather than the source range. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class _OutIt&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a4">copy_from_istream</a> (_OutIt _First, _OutIt _Last, std::istream &amp;in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Although extract and copy_from should, with the help of istream_iterator, be able to fill ranges from input streams, certain difficulties with istreams arise which make the copy_from_istream function useful. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a5">operator&gt;&gt;</a> (std::istream &amp;in, switcher s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input operator for the switcher helper object. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Ty, typename _Ax&gt; std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a6">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; _Ty, _Ax &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic output operator for vectors, requires the vector's contents type to have its own &lt;&lt; operator. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Ty, typename _Ax&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a7">operator&gt;&gt;</a> (std::istream &amp;in, std::vector&lt; _Ty, _Ax &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic input operator for vectors, requires the vector's contents type to have its own &gt;&gt; operator. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Ty, typename _Pr, typename _Alloc&gt; std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a8">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; std::string, _Ty, _Pr, _Alloc &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A specialised output operator for maps with key type string, which uses add_slashes to encode the string. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="serialisation::operator>>"></a>
template&lt;typename _Ty, typename _Pr, typename _Alloc&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a9">operator&gt;&gt;</a> (std::istream &amp;in, const std::map&lt; std::string, _Ty, _Pr, _Alloc &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A specialised input operator for maps with key type string, which uses strip_slashes to decode the string. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Kty, typename _Ty, typename _Pr, typename _Alloc&gt; std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a10">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; _Kty, _Ty, _Pr, _Alloc &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic output operator for maps, requires the map's contents to have its own &lt;&lt; operator. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Kty, typename _Ty, typename _Pr, typename _Alloc&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a11">operator&gt;&gt;</a> (std::istream &amp;in, std::map&lt; _Kty, _Ty, _Pr, _Alloc &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic input operator for maps, requires the map's contents to have its own &gt;&gt; operator. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T1, typename T2&gt; T1 &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a12">stream_convert</a> (T2 &amp;input)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An inline reinterpret cast which may be helpful in outputting enumeration types to streams. </em> <a href="#a12"></a><em><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Currently, the simplest way to store data is by serialisation - simply saving and loading object data as unformatted text. 
<p>
To make it easier for you to implement serialisation for your own classes, a range of functions, classes and macros are provided. <hr><h2>Define Documentation</h2>
<a name="a14" doxytag="serialfuncs.h::IMPLEMENT_IOSTREAM_BINARY_CONVERSION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define IMPLEMENT_IOSTREAM_BINARY_CONVERSION</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">_Ty&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">inline</span> std::ostream&amp; <a class="code" href="group__serialisation.html#a6">operator&lt;&lt;</a>(std::ostream&amp; out, _Ty&amp; i)  \
{                                                           \
    out.write(reinterpret_cast&lt;char*&gt;(&amp;i), <span class="keyword">sizeof</span>(i));      \
    <span class="keywordflow">return</span> out;                                             \
}                                                           \
                                                            \
<span class="keyword">inline</span> std::istream&amp; <a class="code" href="group__serialisation.html#a5">operator&gt;&gt;</a>(std::istream&amp; in, _Ty&amp; i)   \
{                                                           \
    in.read(reinterpret_cast&lt;char*&gt;(&amp;i), <span class="keyword">sizeof</span>(i));        \
    <span class="keywordflow">return</span> in;                                              \
}
</pre></div>This macro is intended as a quick solution to the problem of encoding structs and classes into output streams. 
<p>
A binary conversion is performed, meaning that any pointers and complex data types (e.g. vectors) will be rendered nonsensical to the input operator. Only for use on simple structs and classes containing non-pointer types. Also, output produced by these functions is unlikely to transfer between platforms due to differing number formats. This is only a temporary solution and should be replaced with special input/output operators.     </td>
  </tr>
</table>
<a name="a13" doxytag="serialfuncs.h::IMPLEMENT_IOSTREAM_CAST"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define IMPLEMENT_IOSTREAM_CAST</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">_Ty,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>_Cast&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">inline</span> std::ostream&amp; <a class="code" href="group__serialisation.html#a6">operator&lt;&lt;</a>(std::ostream&amp; out, _Ty&amp; i)  \
{                                                           \
    out &lt;&lt; static_cast&lt;_Cast&gt;(i);                           \
    <span class="keywordflow">return</span> out;                                             \
}                                                           \
                                                            \
<span class="keyword">inline</span> std::istream&amp; <a class="code" href="group__serialisation.html#a5">operator&gt;&gt;</a>(std::istream&amp; in, _Ty&amp; i)   \
{                                                           \
    _Cast input;                                            \
    in &gt;&gt; input;                                            \
    i = static_cast&lt;_Ty&gt;(input);                            \
    <span class="keywordflow">return</span> in;                                              \
}
</pre></div>Use this macro to create a custom output operator which simply casts _Ty to the type specified by _Cast. 
<p>
Useful for converting enum types to ints which may then be input and output in the usual way.     </td>
  </tr>
</table>
<a name="a15" doxytag="serialfuncs.h::IMPLEMENT_SERIALISATION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define IMPLEMENT_SERIALISATION</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">_Name,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>_Parent&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre><span class="keyword">public</span>:                                                             \
    <span class="keywordtype">void</span> Serialise(std::ostream&amp; out)<span class="keyword">const</span>                          \
    {                                                               \
        out &lt;&lt; _Name &lt;&lt; <span class="stringliteral">"\n"</span>;                                       \
        _Parent::Serialise(out);                                    \
    }                                                               \
                                                                    \
    <span class="keywordtype">void</span> Unserialise(std::istream&amp; in)                              \
    {                                                               \
        std::string name;                                           \
        in &gt;&gt; name;                                                 \
        <span class="keywordflow">if</span> (name != _Name) {                                        \
            <span class="keywordflow">throw</span> SerialException(SERIAL_ERROR_WRONG_TYPE, name,    \
                    std::string(<span class="stringliteral">"This object is type "</span>) + _Name);   \
        }                                                           \
        _Parent::Unserialise(in);                                   \
    }
</pre></div>Use this macro to add basic serialisation functionality to your derived classes by simply serialising under a new name, but using the parent serialisation methods. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a name="a17" doxytag="BEAST::SerialErrorType"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="group__serialisation.html#a17">BEAST::SerialErrorType</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerates the different types of errors encountered in serialisation. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="a17a65" doxytag="SERIAL_ERROR_UNKNOWN"></a><em>SERIAL_ERROR_UNKNOWN</em></em>&nbsp;</td><td>
An unknown problem. </td></tr>
<tr><td valign=top><em><a name="a17a66" doxytag="SERIAL_ERROR_BAD_FILE"></a><em>SERIAL_ERROR_BAD_FILE</em></em>&nbsp;</td><td>
Unable to open or write to the file. </td></tr>
<tr><td valign=top><em><a name="a17a67" doxytag="SERIAL_ERROR_WRONG_TYPE"></a><em>SERIAL_ERROR_WRONG_TYPE</em></em>&nbsp;</td><td>
Incoming data has the wrong type label. </td></tr>
<tr><td valign=top><em><a name="a17a68" doxytag="SERIAL_ERROR_UNKNOWN_TYPE"></a><em>SERIAL_ERROR_UNKNOWN_TYPE</em></em>&nbsp;</td><td>
Incoming data has an unknown type label. </td></tr>
<tr><td valign=top><em><a name="a17a69" doxytag="SERIAL_ERROR_DATA_MISMATCH"></a><em>SERIAL_ERROR_DATA_MISMATCH</em></em>&nbsp;</td><td>
The wrong type of data seems to be coming in. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a3" doxytag="BEAST::copy_from"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class _InIt, class _OutIt&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> _InIt copy_from </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">_OutIt&nbsp;</td>
          <td class="mdname" nowrap> <em>_First</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>_OutIt&nbsp;</td>
          <td class="mdname" nowrap> <em>_Last</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>_InIt&nbsp;</td>
          <td class="mdname" nowrap> <em>_Src</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An algorithm similar to copy, but where the start and end of the target range is specified rather than the source range. 
<p>
For example, to copy from a vector of unknown length into a range of known length: <code> vector&lt;int&gt; target(30); vector&lt;int&gt; source(rand(100) + 30); copy_from(target.begin(), target.end(), source.begin()); </code> <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__serialisation.html#a2">extract</a> for another way of doing exactly the same thing. </dd></dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="BEAST::copy_from_istream"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class _OutIt&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::istream&amp; copy_from_istream </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">_OutIt&nbsp;</td>
          <td class="mdname" nowrap> <em>_First</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>_OutIt&nbsp;</td>
          <td class="mdname" nowrap> <em>_Last</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::istream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Although extract and copy_from should, with the help of istream_iterator, be able to fill ranges from input streams, certain difficulties with istreams arise which make the copy_from_istream function useful. 
<p>
Simply specify the start and end iterators of the range to be filled and an input stream to use as the source.     </td>
  </tr>
</table>
<a name="a2" doxytag="BEAST::extract"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class _Iterator&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> extractor&lt;_Iterator&gt; extract </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">_Iterator &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>Iter</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs and returns an extractor of the correct type. 
<p>
For example, to copy from a vector of unknown length into a range of known length: <code> vector&lt;int&gt; target(30); vector&lt;int&gt; source(rand(100) + 30); generate(target.begin(), target.end(), extract(source.begin())); </code> <dl compact><dt><b>See also:</b></dt><dd><a class="el" href="structBEAST_1_1extractor.html">extractor</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="BEAST::operator<<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename _Kty, typename _Ty, typename _Pr, typename _Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::map&lt; _Kty, _Ty, _Pr, _Alloc &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A generic output operator for maps, requires the map's contents to have its own &lt;&lt; operator. 
<p>
The size is output, followed by each key and value, separated by spaces.     </td>
  </tr>
</table>
<a name="a8" doxytag="BEAST::operator<<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename _Ty, typename _Pr, typename _Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::map&lt; std::string, _Ty, _Pr, _Alloc &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A specialised output operator for maps with key type string, which uses add_slashes to encode the string. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="namespaceBEAST.html#a96">add_slashes</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a6" doxytag="BEAST::operator<<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename _Ty, typename _Ax&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::vector&lt; _Ty, _Ax &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A generic output operator for vectors, requires the vector's contents type to have its own &lt;&lt; operator. 
<p>
The size is output, followed by each entry, separated by spaces.     </td>
  </tr>
</table>
<a name="a11" doxytag="BEAST::operator>>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename _Kty, typename _Ty, typename _Pr, typename _Alloc&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::istream&amp; operator&gt;&gt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::istream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::map&lt; _Kty, _Ty, _Pr, _Alloc &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>m</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A generic input operator for maps, requires the map's contents to have its own &gt;&gt; operator. 
<p>
The size is read, followed by each key and value.     </td>
  </tr>
</table>
<a name="a7" doxytag="BEAST::operator>>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename _Ty, typename _Ax&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::istream&amp; operator&gt;&gt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::istream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::vector&lt; _Ty, _Ax &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>v</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A generic input operator for vectors, requires the vector's contents type to have its own &gt;&gt; operator. 
<p>
The size is input, followed by each entry.     </td>
  </tr>
</table>
<a name="a5" doxytag="BEAST::operator>>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::istream&amp; operator&gt;&gt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::istream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>switcher&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Input operator for the switcher helper object. 
<p>
Note that unlike most input operators, this one does not take a reference to the switcher, since the switcher is intended for instantiation at the time of input.     </td>
  </tr>
</table>
<a name="a12" doxytag="BEAST::stream_convert"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T1, typename T2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T1&amp; stream_convert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T2 &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>input</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An inline reinterpret cast which may be helpful in outputting enumeration types to streams. 
<p>
Probaly better to use IMPLEMENT_IOSTREAM_CAST or ideally, write your own input/output operators for your types.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:26:37 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
