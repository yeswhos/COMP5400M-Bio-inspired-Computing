<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: utilities.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>utilities.h</h1><a href="utilities_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00008 <span class="preprocessor">#ifndef _UTILITIES_H</span>
00009 <span class="preprocessor"></span><span class="preprocessor">#define _UTILITIES_H</span>
00010 <span class="preprocessor"></span>
00011 <span class="preprocessor">#include &lt;typeinfo&gt;</span>
00012 <span class="preprocessor">#include &lt;functional&gt;</span>
00013 
00014 <span class="keyword">namespace </span>BEAST {
00015 
00028 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Owner, <span class="keyword">typename</span> _Type, <span class="keyword">typename</span> _In = _Type, <span class="keyword">typename</span> _Out = _In&gt;
<a name="l00029"></a><a class="code" href="classBEAST_1_1property.html">00029</a> <span class="keyword">class </span><a class="code" href="classBEAST_1_1property.html">property</a>
00030 {
00031 <span class="keyword">public</span>:
00032     <a class="code" href="classBEAST_1_1property.html">property</a>()
00033     {
00034     }
00035 
00036     <a class="code" href="classBEAST_1_1property.html">property</a>(_Owner* t, _Out (_Owner::*get)(<span class="keywordtype">void</span>)<span class="keyword">const</span>, <span class="keywordtype">void</span> (_Owner::*set)(_In)):
00037     that(t), _Get(get), _Set(set)
00038     {
00039     }
00040 
00041     <span class="keywordtype">void</span> init(_Owner* t, _Out (_Owner::*get)(<span class="keywordtype">void</span>)<span class="keyword">const</span>, <span class="keywordtype">void</span> (_Owner::*set)(_In))
00042     {
00043         that = t;
00044         _Get = get;
00045         _Set = set;
00046     }
00047 
00048     <a class="code" href="classBEAST_1_1property.html">property</a>&amp; operator=(_In v)
00049     {
00050         (that-&gt;*_Set)(v);
00051         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00052     }
00053 
00054     operator _Out()
00055     {
00056         <span class="keywordflow">return</span> (that-&gt;*_Get)();
00057     }
00058 
00059     _Type* operator-&gt;()<span class="keyword">const</span>
00060     {
00061         <span class="keywordflow">return</span> &amp;((that-&gt;*_Get)());
00062     }
00063 
00064     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CastType&gt;
00065     _CastType as()<span class="keyword">const</span>
00066     {
00067         <span class="keywordflow">return</span> static_cast&lt;_CastType&gt;((that-&gt;*_Get)());
00068     }
00069 
00070 <span class="keyword">private</span>:
00071     _Owner* that;
00072     _Out (_Owner::*_Get)(<span class="keywordtype">void</span>)<span class="keyword">const</span>;
00073     void (_Owner::*_Set)(_In);
00074 };
00075 
00076 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Owner, <span class="keyword">typename</span> _Type, <span class="keyword">typename</span> _In = _Type, <span class="keyword">typename</span> _Out = _In&gt;
00077 <span class="keyword">class </span>pointer_property : <span class="keyword">public</span> property&lt;_Owner, _Type, _In, _Out&gt;
00078 {
00079     pointer_property()
00080     {
00081     }
00082 
00083     pointer_property(_Owner* t, _Out (_Owner::*get)(<span class="keywordtype">void</span>)<span class="keyword">const</span>, <span class="keywordtype">void</span> (_Owner::*set)(_In)):
00084         property&lt;_Owner, _Type, _In, _Out&gt;(t, get, set)
00085     {
00086     }
00087 
00088     _Type operator-&gt;()<span class="keyword">const</span>
00089     {
00090         <span class="keywordflow">return</span> ((that-&gt;*_Get)());
00091     }
00092 
00093     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CastType&gt;
00094     _CastType as()<span class="keyword">const</span>
00095     {
00096         <span class="keywordflow">return</span> dynamic_cast&lt;_CastType&gt;((that-&gt;*_Get)());
00097     }
00098 };
00099 
00100 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Type, <span class="keyword">typename</span> _In = _Type, <span class="keyword">typename</span> _Out = _In&gt;
00101 <span class="keyword">class </span>auto_property
00102 {
00103 <span class="keyword">public</span>:
00104     auto_property(_Type&amp; v): value(v)
00105     {
00106     }
00107 
00108     auto_property&amp; operator=(_In v)
00109     {
00110         value = v;
00111         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00112     }
00113 
00114     operator _Out()<span class="keyword">const</span>
00115     {
00116         <span class="keywordflow">return</span> value;
00117     }
00118 
00119     _Type* operator-&gt;()<span class="keyword">const</span>
00120     {
00121         <span class="keywordflow">return</span> &amp;value;
00122     }
00123 
00124     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CastType&gt;
00125     _CastType as()<span class="keyword">const</span>
00126     {
00127         <span class="keywordflow">return</span> static_cast&lt;_CastType&gt;(value);
00128     }
00129 
00130 <span class="keyword">protected</span>:
00131     _Type&amp; value;
00132 };
00133 
00134 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Type, <span class="keyword">typename</span> _In = _Type, <span class="keyword">typename</span> _Out = _In&gt;
00135 <span class="keyword">class </span>auto_pointer_property : <span class="keyword">public</span> auto_property&lt;_Type, _In, _Out&gt;
00136 {
00137 <span class="keyword">public</span>:
00138     auto_pointer_property(_Type&amp; v): auto_property&lt;_Type, _In, _Out&gt;(v)
00139     {}
00140 
00141     _Type operator-&gt;()<span class="keyword">const</span>
00142     {
00143         <span class="keywordflow">return</span> value;
00144     }
00145 
00146     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CastType&gt;
00147     _CastType as()<span class="keyword">const</span>
00148     {
00149         <span class="keywordflow">return</span> dynamic_cast&lt;_CastType&gt;(value);
00150     }
00151 };
00152 
00153 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Type, <span class="keyword">typename</span> _In = _Type, <span class="keyword">typename</span> _Out = _In, <span class="keyword">typename</span> _Key = <span class="keyword">typename</span> _Type::key_type,
00154           <span class="keyword">typename</span> _Data = <span class="keyword">typename</span> _Type::mapped_type, <span class="keyword">typename</span> _Output = auto_property&lt;_Data&gt; &gt;
00155 <span class="keyword">class </span>auto_indexed_property : <span class="keyword">public</span> auto_property&lt;_Type, _In, _Out&gt;
00156 {
00157 <span class="keyword">public</span>:
00158     auto_indexed_property(_Type&amp; v): auto_property&lt;_Type, _In, _Out&gt;(v)
00159     {
00160     }
00161 
00162     _Output operator[](_Key k)
00163     {
00164         <span class="keywordflow">return</span> _Output(value[k]);
00165     }
00166 };
00167 
00168 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Type, <span class="keyword">typename</span> _In = _Type, <span class="keyword">typename</span> _Out = _In, <span class="keyword">typename</span> _Key = <span class="keyword">typename</span> _Type::key_type,
00169           <span class="keyword">typename</span> _Data = <span class="keyword">typename</span> _Type::mapped_type, <span class="keyword">typename</span> _Output = auto_pointer_property&lt;_Data&gt; &gt;
00170 <span class="keyword">class </span>auto_indexed_pointer_property : <span class="keyword">public</span> auto_property&lt;_Type, _In, _Out&gt;
00171 {
00172 <span class="keyword">public</span>:
00173     auto_indexed_pointer_property(_Type&amp; v): auto_property&lt;_Type, _In, _Out&gt;(v)
00174     {
00175     }
00176 
00177     _Output operator[](_Key k)
00178     {
00179         <span class="keywordflow">return</span> _Output(value[k]);
00180     }
00181 };
00182 
00188 <span class="keyword">template</span>&lt;<span class="keyword">class</span> _InIt, <span class="keyword">class</span> _Ty, <span class="keyword">class</span> _Fn1&gt; <span class="keyword">inline</span>
<a name="l00189"></a><a class="code" href="group__utilities.html#a12">00189</a> _Ty <a class="code" href="group__utilities.html#a12">accumulate_fun</a>(_InIt _First, _InIt _Last, _Ty _Val, _Fn1 _Func)
00190 {   
00191     <span class="keywordflow">for</span> (; _First != _Last; ++_First)
00192         _Val += _Func(*_First);
00193     <span class="keywordflow">return</span> (_Val);
00194 }
00195 
00200 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">typename</span> M, <span class="keyword">class</span> OP&gt;
<a name="l00201"></a><a class="code" href="classBEAST_1_1call__on__mem__t.html">00201</a> <span class="keyword">class </span><a class="code" href="classBEAST_1_1call__on__mem__t.html">call_on_mem_t</a> : std::unary_function&lt;T, typename OP::result_type&gt;
00202 {
00203 <span class="keyword">public</span>:
00204     <span class="keyword">typedef</span> M argument_type;
00205     <span class="keyword">typedef</span> <span class="keyword">typename</span> OP::result_type result_type;
00206 
00207     <span class="keyword">explicit</span> <a class="code" href="classBEAST_1_1call__on__mem__t.html">call_on_mem_t</a>(M T:: *m, OP op):
00208         m_(m), op_(op) {}
00209 
00210     result_type operator()(T &amp;val)
00211     {
00212         <span class="keywordflow">return</span> op_(val.*m_);
00213     }
00214 <span class="keyword">private</span>:
00215     M T::* m_;
00216     OP op_;
00217 };
00218 
00222 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">typename</span> M, <span class="keyword">class</span> OP&gt;
00223 call_on_mem_t&lt;T, M, OP&gt;
<a name="l00224"></a><a class="code" href="group__utilities.html#a13">00224</a> <a class="code" href="group__utilities.html#a13">call_on_mem</a>(M T::*m, OP op)
00225 {
00226     <span class="keywordflow">return</span> call_on_mem_t&lt;T, M, OP&gt;(m, op);
00227 }
00228 
00235 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Class, <span class="keyword">typename</span> _Return, <span class="keyword">typename</span> _Arg&gt;
<a name="l00236"></a><a class="code" href="structBEAST_1_1bound__mem__fun__t.html">00236</a> <span class="keyword">struct </span><a class="code" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a> : std::unary_function&lt;_Return, _Arg&gt;
00237 {
00238     <a class="code" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a>(_Class&amp; t, _Return (_Class::*m)(_Arg)):
00239     that(t), memfun(m) {}
00240     _Return operator()(_Arg a)
00241     {
00242         <span class="keywordflow">return</span> (that.*memfun)(a);
00243     }
00244 
00245     _Return (_Class::*memfun)(_Arg);
00246     _Class&amp; that;
00247 };
00248 
00252 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Class, <span class="keyword">typename</span> _Return, <span class="keyword">typename</span> _Arg&gt;
<a name="l00253"></a><a class="code" href="group__utilities.html#a14">00253</a> <span class="keyword">inline</span> bound_mem_fun_t&lt;_Class, _Return, _Arg&gt; <a class="code" href="group__utilities.html#a14">bound_mem_fun</a>(_Class&amp; c, _Return (_Class::*memfun)(_Arg))
00254 {
00255     <span class="keywordflow">return</span> bound_mem_fun_t&lt;_Class, _Return, _Arg&gt;(c, memfun);
00256 }
00257 
00261 <span class="keyword">template</span> &lt;<span class="keyword">class</span> _Class, <span class="keyword">typename</span> _Return, <span class="keyword">typename</span> _Arg&gt;
<a name="l00262"></a><a class="code" href="group__utilities.html#a15">00262</a> <span class="keyword">inline</span> bound_mem_fun_t&lt;_Class, _Return, _Arg&gt; <a class="code" href="group__utilities.html#a14">bound_mem_fun</a>(_Class* c, _Return (_Class::*memfun)(_Arg))
00263 {
00264     <span class="keywordflow">return</span> bound_mem_fun_t&lt;_Class, _Return, _Arg&gt;(*c, memfun);
00265 }
00266 
00267 
00272 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00273"></a><a class="code" href="structBEAST_1_1creator.html">00273</a> <span class="keyword">struct </span><a class="code" href="structBEAST_1_1creator.html">creator</a> : <span class="keyword">public</span> std::unary_function&lt;void, T*&gt; {
00274     T* operator()()
00275     {
00276         <span class="keywordflow">return</span> <span class="keyword">new</span> T;
00277     }
00278 };
00279 
00284 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00285"></a><a class="code" href="structBEAST_1_1deleter.html">00285</a> <span class="keyword">struct </span><a class="code" href="structBEAST_1_1deleter.html">deleter</a> : <span class="keyword">public</span> std::unary_function&lt;T*, void&gt; {
00286     <span class="keywordtype">void</span> operator()(T* obj)
00287     {
00288         <span class="keyword">delete</span> obj;
00289     }
00290 };
00291 
00302 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Type, <span class="keyword">typename</span> _Base&gt;
<a name="l00303"></a><a class="code" href="group__utilities.html#a16">00303</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__utilities.html#a16">IsA</a>(_Base* in, _Type*&amp; out)
00304 {
00305     <span class="keywordflow">if</span> (in == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00306 
00307     <span class="keywordflow">if</span> (<span class="keyword">typeid</span>(*in) == <span class="keyword">typeid</span>(_Type)) {
00308         out = static_cast&lt;_Type*&gt;(in);
00309         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00310     }
00311     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00312 }
00313 
00324 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Type, <span class="keyword">typename</span> _Base&gt;
<a name="l00325"></a><a class="code" href="group__utilities.html#a17">00325</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="group__utilities.html#a17">IsKindOf</a>(_Base* in, _Type*&amp; out)
00326 {
00327     <span class="keywordflow">if</span> (in == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00328 
00329     out = dynamic_cast&lt;_Type*&gt;(in);
00330     <span class="keywordflow">return</span> out != NULL;
00331 }
00332 
00342 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00343"></a><a class="code" href="group__utilities.html#a18">00343</a> <span class="keyword">inline</span> T <a class="code" href="group__utilities.html#a18">bound</a>(T L, T U, T n)
00344 {
00345     <span class="keywordflow">while</span> (n &gt;= U) n -= (U - L);
00346     <span class="keywordflow">while</span> (n &lt; L) n += (U - L);
00347     <span class="keywordflow">return</span> n;
00348 }
00349 
00357 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00358"></a><a class="code" href="group__utilities.html#a19">00358</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__utilities.html#a19">rbound</a>(T L, T U, T&amp; n)
00359 {
00360     <span class="keywordflow">while</span> (n &gt;= U) n -= (U - L);
00361     <span class="keywordflow">while</span> (n &lt; L) n += (U - L);
00362 }
00363 
00372 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00373"></a><a class="code" href="group__utilities.html#a20">00373</a> <span class="keyword">inline</span> T <a class="code" href="group__utilities.html#a20">limit</a>(T L, T U, T n)
00374 {
00375     <span class="keywordflow">if</span> (n &gt; U) <span class="keywordflow">return</span> U;
00376     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n &lt; L) <span class="keywordflow">return</span> L;
00377     <span class="keywordflow">else</span> <span class="keywordflow">return</span> n;
00378 }
00379 
00388 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00389"></a><a class="code" href="group__utilities.html#a21">00389</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__utilities.html#a21">rlimit</a>(T L, T U, T&amp; n)
00390 {
00391     <span class="keywordflow">if</span> (n &gt; U) n = U;
00392     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n &lt; L) n = L;
00393 }
00394 
00399 } <span class="comment">// namespace BEAST</span>
00400 
00401 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:25:35 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
