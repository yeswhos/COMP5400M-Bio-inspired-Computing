<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: Annotated Index</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindexHL" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit Compound List</h1>Here are the classes, structs, unions and interfaces with brief descriptions:<table>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Animat.html">BEAST::Animat</a></td><td class="indexvalue">Animats can move around and interact with other objects in the world </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1AreaSensor.html">BEAST::AreaSensor</a></td><td class="indexvalue">Detects objects within an area specified by the size and shape of the <a class="el" href="classBEAST_1_1AreaSensor.html">AreaSensor</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Bacterium.html">BEAST::Bacterium</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1BeamSensor.html">BEAST::BeamSensor</a></td><td class="indexvalue">BeamSensors can really be three distinct kinds of sensor: Lasers, which just detect objects a certain distance away in a straight line from the sensor's origin </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1bound__mem__fun__t.html">BEAST::bound_mem_fun_t&lt; _Class, _Return, _Arg &gt;</a></td><td class="indexvalue">A functor which creates a unary function from a unary member function, binding an instance of the class to which the function belongs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1call__on__mem__t.html">BEAST::call_on_mem_t&lt; T, M, OP &gt;</a></td><td class="indexvalue">Allows us to bind functors so that they work on particular members of classes, useful for using for_each on maps </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1creator.html">BEAST::creator&lt; T &gt;</a></td><td class="indexvalue">A functor for use with the for_each algorithm which can perform creation of objects when called on a container of pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1deleter.html">BEAST::deleter&lt; T &gt;</a></td><td class="indexvalue">A functor for use with the for_each algorithm which can perform deletion of objects when called on a container of pointers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Distribution.html">BEAST::Distribution</a></td><td class="indexvalue">Implements a grid which stores spatial density information to a specified resolution, e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1Distribution_1_1Kernel.html">BEAST::Distribution::Kernel</a></td><td class="indexvalue">Implements diffusion and other neighbourhood operations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1DNNAnimat.html">BEAST::DNNAnimat</a></td><td class="indexvalue">An <a class="el" href="classBEAST_1_1Animat.html">Animat</a> with a built-in dynamical network which is automatically configured depending on the Animat's sensor and control configuration </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1DynamicalNet.html">BEAST::DynamicalNet</a></td><td class="indexvalue">This class implements a fully recurrent continuous (or dynamical) neural network </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1DynamicalNet_1_1Neuron.html">BEAST::DynamicalNet::Neuron</a></td><td class="indexvalue">Unlike the <a class="el" href="classBEAST_1_1FeedForwardNet.html">FeedForwardNet</a>, the <a class="el" href="structBEAST_1_1DynamicalNet_1_1Neuron.html">Neuron</a> in <a class="el" href="classBEAST_1_1DynamicalNet.html">DynamicalNet</a> is more worthy of its name, since nearly all the processing of the DNN's firing algorithm occurs here </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvalNearest.html">BEAST::EvalNearest</a></td><td class="indexvalue">Keeps a tally of the nearest point passed in and returns it with GetOutput </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvalNearestAbsX.html">BEAST::EvalNearestAbsX</a></td><td class="indexvalue">Returns the absolute x position of the nearest target </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvalNearestAbsY.html">BEAST::EvalNearestAbsY</a></td><td class="indexvalue">Returns the absolute y position of the nearest target </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvalNearestAngle.html">BEAST::EvalNearestAngle</a></td><td class="indexvalue">Returns the normalised angle to the nearest target </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvalNearestSignal.html">BEAST::EvalNearestSignal&lt; _State, _Signal, _Cost &gt;</a></td><td class="indexvalue"><a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> evaluation functor: returns the signal of the nearest individual </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvalNearestXDist.html">BEAST::EvalNearestXDist</a></td><td class="indexvalue">Returns the vertical distance to the nearest target </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvalNearestYDist.html">BEAST::EvalNearestYDist</a></td><td class="indexvalue">Returns the horizontal distance to the nearest target </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvoDNNAnimat.html">BEAST::EvoDNNAnimat</a></td><td class="indexvalue">An evolvable version of <a class="el" href="classBEAST_1_1DNNAnimat.html">DNNAnimat</a> with GetGenotype/SetGenotype methods already set up </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1EvoFFNAnimat.html">BEAST::EvoFFNAnimat</a></td><td class="indexvalue">An evolvable version of <a class="el" href="classBEAST_1_1FFNAnimat.html">FFNAnimat</a> with GetGenotype/SetGenotype methods already set up </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Evolver.html">BEAST::Evolver&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1extractor.html">BEAST::extractor&lt; _Iterator &gt;</a></td><td class="indexvalue">This is a function object which can be used for copying from an iterator when the number of input values is unknown </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1FeedForwardNet.html">BEAST::FeedForwardNet</a></td><td class="indexvalue">This is an implementation of a simple two-layer feed-forward neural network </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1FeedForwardNet_1_1Neuron.html">BEAST::FeedForwardNet::Neuron</a></td><td class="indexvalue">This member struct simply encapsulates the weighted sum function which has to be performed on the weights of each node when the net fires </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1FFNAnimat.html">BEAST::FFNAnimat</a></td><td class="indexvalue">An <a class="el" href="classBEAST_1_1Animat.html">Animat</a> with a built-in feed-forward network which is automatically configured depending on the Animat's sensor and control configuration </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1Gaussian2D.html">BEAST::Gaussian2D</a></td><td class="indexvalue">Plots a two-dimensional Gaussian function in a distribution or distribution kernel </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1GaussianNoise.html">BEAST::GaussianNoise</a></td><td class="indexvalue">Plots normally distributed noise in a distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1GaussianRing2D.html">BEAST::GaussianRing2D</a></td><td class="indexvalue">Plots a two dimensional Gaussian ring </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1GAVariant.html">BEAST::GAVariant</a></td><td class="indexvalue">This is a general purpose data type which takes five basic data types: int, float, double, char and bool </td></tr>
  <tr><td class="indexkey"><a class="el" href="unionBEAST_1_1GAVariant_1_1VariantData.html">BEAST::GAVariant::VariantData</a></td><td class="indexvalue">Union of five data types for <a class="el" href="structBEAST_1_1GAVariant.html">GAVariant</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1GeneticAlgorithm.html">BEAST::GeneticAlgorithm&lt; EVO, MUTFUNC &gt;</a></td><td class="indexvalue">The <a class="el" href="classBEAST_1_1GeneticAlgorithm.html">GeneticAlgorithm</a> class provides functionality to cover a range of GA methods, and may be extended to incorporate other approaches </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1GeneticAlgorithm_1_1evo__sort.html">BEAST::GeneticAlgorithm&lt; EVO, MUTFUNC &gt;::evo_sort&lt; _EVO &gt;</a></td><td class="indexvalue">A little function object to enable us to sort the population by fitness </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Group.html">BEAST::Group&lt; _ObjType &gt;</a></td><td class="indexvalue">A simple class which creates and maintains a vector of objects of the specified type and adds them to the world each round </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MatchAdapter.html">BEAST::MatchAdapter&lt; _Functor &gt;</a></td><td class="indexvalue">Allows any unary predicate to be adapted for use as a matching function </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MatchComposeAnd.html">BEAST::MatchComposeAnd</a></td><td class="indexvalue">Chains any number of matching functions together such that only if all of them are true for the object being matched, <a class="el" href="structBEAST_1_1MatchComposeAnd.html">MatchComposeAnd</a> will return true </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MatchComposeOr.html">BEAST::MatchComposeOr</a></td><td class="indexvalue">Chains any number of matching functions together such that should any of them be true for the object being matched, <a class="el" href="structBEAST_1_1MatchComposeOr.html">MatchComposeOr</a> will return true </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MatchExact.html">BEAST::MatchExact&lt; _ObjectType &gt;</a></td><td class="indexvalue">Identifies exact object types, so if defined with Cheese, will return true only for Cheese, and false for Cheddar and Gruyère </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MatchKindOf.html">BEAST::MatchKindOf&lt; _ObjectType &gt;</a></td><td class="indexvalue">Identifies objects belonging to hierarchies, so if defined with Cheese, will return true for objects of type Cheese, or derived classes such as Cheddar and Gruyère </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MatchSpecific.html">BEAST::MatchSpecific</a></td><td class="indexvalue">Identifies one particular object and returns true only for that object </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MutationOperator.html">BEAST::MutationOperator&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MutationOperator_3_01bool_01_4.html">BEAST::MutationOperator&lt; bool &gt;</a></td><td class="indexvalue">Specialised <a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a> for bool, simply NOT's its input </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1MutationOperator_3_01GAVariant_01_4.html">BEAST::MutationOperator&lt; GAVariant &gt;</a></td><td class="indexvalue">This specialised mutation operator provides the facilities of the basic <a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a> for <a class="el" href="structBEAST_1_1GAVariant.html">GAVariant</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1ObjLoader.html">BEAST::ObjLoader&lt; _Type &gt;</a></td><td class="indexvalue">A functor for recreating templated object types using serialisation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1ObjLoaderBase.html">BEAST::ObjLoaderBase</a></td><td class="indexvalue">A simple abstract base class for <a class="el" href="structBEAST_1_1ObjLoader.html">ObjLoader</a> functors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Population.html">BEAST::Population&lt; _Ind, _MutFunc &gt;</a></td><td class="indexvalue">This class is derived from <a class="el" href="classBEAST_1_1Group.html">Group</a> and adds a managed GA which is automatically run on the whole <a class="el" href="classBEAST_1_1Population.html">Population</a> every epoch </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1property.html">BEAST::property&lt; _Owner, _Type, _In, _Out &gt;</a></td><td class="indexvalue">Class wrapper for a member variable which allows member data to be exposed with invisible get/set semantics </td></tr>
  <tr><td class="indexkey"><a class="el" href="structRandom.html">Random&lt; _Type &gt;</a></td><td class="indexvalue">Function object version of randval </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1Ring2D.html">BEAST::Ring2D</a></td><td class="indexvalue">Plots a two dimensional ring </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1ScaleAbs.html">BEAST::ScaleAbs</a></td><td class="indexvalue">Returns the absolute value of the input, as for the std::abs function </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1ScaleAdapter.html">BEAST::ScaleAdapter&lt; _Functor &gt;</a></td><td class="indexvalue">Allows any unary functor to be adapted for use as a scaling function </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1ScaleCompose.html">BEAST::ScaleCompose</a></td><td class="indexvalue"><a class="el" href="structBEAST_1_1ScaleCompose.html">ScaleCompose</a> allows the chaining of two scaling functions together, such the output of a <a class="el" href="structBEAST_1_1ScaleCompose.html">ScaleCompose</a> functor is the result of second(first(input)), where first and second are the arguments in ScaleCompose's constructor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1ScaleLinear.html">BEAST::ScaleLinear</a></td><td class="indexvalue">A simple linear scaling function which defaults to an input scale between 0 and a defined maximum, scaling to an output range between 0 and 1 </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1ScaleNoise.html">BEAST::ScaleNoise</a></td><td class="indexvalue"><a class="el" href="structBEAST_1_1ScaleNoise.html">ScaleNoise</a> adds uniform random noise to its input </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1ScaleThreshold.html">BEAST::ScaleThreshold</a></td><td class="indexvalue"><a class="el" href="structBEAST_1_1ScaleThreshold.html">ScaleThreshold</a> takes values: threshold, min and max and returns min if input &lt; threshold, or max if input &gt;= threshold </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1SelfSensor.html">BEAST::SelfSensor</a></td><td class="indexvalue">The <a class="el" href="classBEAST_1_1SelfSensor.html">SelfSensor</a> is used to detect information about its owner </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Sensor.html">BEAST::Sensor</a></td><td class="indexvalue">The <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> class is the base class for all the different types of sensor: <a class="el" href="classBEAST_1_1TouchSensor.html">TouchSensor</a>, <a class="el" href="classBEAST_1_1SelfSensor.html">SelfSensor</a>, <a class="el" href="classBEAST_1_1AreaSensor.html">AreaSensor</a> and <a class="el" href="classBEAST_1_1BeamSensor.html">BeamSensor</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1SensorEvalFunction.html">BEAST::SensorEvalFunction</a></td><td class="indexvalue">Abstract base class for evaluation functors </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1SensorMatchFunction.html">BEAST::SensorMatchFunction</a></td><td class="indexvalue">Abstract base class for matching functors </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1SensorScaleFunction.html">BEAST::SensorScaleFunction</a></td><td class="indexvalue">Abstract base class for scaling functors </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1SerialException.html">BEAST::SerialException</a></td><td class="indexvalue">Since exceptions have an undesirable overhead, they have not been used elsewhere in the simulation environment for reasons of speed </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Signaller.html">BEAST::Signaller&lt; _State, _Signal, _Cost &gt;</a></td><td class="indexvalue">A general-purpose class for modelling signallers with discrete signal and state types </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1SimObject.html">BEAST::SimObject</a></td><td class="indexvalue">An abstract base class for the <a class="el" href="classBEAST_1_1Population.html">Population</a> template, allowing populations with different templated types to be represented in <a class="el" href="classBEAST_1_1Simulation.html">Simulation</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Simulation.html">BEAST::Simulation</a></td><td class="indexvalue">The basic <a class="el" href="classBEAST_1_1Simulation.html">Simulation</a> framework which must be derived to set up simulations </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1switcher.html">BEAST::switcher</a></td><td class="indexvalue">The switcher is useful when configuring bools from string data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1TouchSensor.html">BEAST::TouchSensor</a></td><td class="indexvalue">Detects objects which are touching the sensor's owner </td></tr>
  <tr><td class="indexkey"><a class="el" href="structBEAST_1_1UniformNoise.html">BEAST::UniformNoise</a></td><td class="indexvalue">Plots uniform noise in a distribution </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Unserialiser.html">BEAST::Unserialiser</a></td><td class="indexvalue">This class is available for unserialising objects from streams, without knowing which type of object is to be unserialised - the type is determined from the header of the stream </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Vector2D.html">BEAST::Vector2D</a></td><td class="indexvalue">A class for representing two-dimensional vectors and coordinates </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1Wall.html">BEAST::Wall</a></td><td class="indexvalue">This is a handy class for putting the most common type of obstacle - walls - into the world </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1World.html">BEAST::World</a></td><td class="indexvalue">This is where it all happens: <a class="el" href="classBEAST_1_1World.html">World</a> contains pointers to every object in the simulation environment and allows those objects to interact with each other, and then be displayed </td></tr>
  <tr><td class="indexkey"><a class="el" href="classBEAST_1_1WorldObject.html">BEAST::WorldObject</a></td><td class="indexvalue">The base class for everything that makes a difference in the world, including Animats, Sensors and all types of scenery and interactive object </td></tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:26:29 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
