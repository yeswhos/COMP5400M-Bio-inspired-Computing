<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: Tutorial 1: Building your first Animat</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a name="tutorial1">Tutorial 1: Building your first Animat</a>
</h1>In this tutorial we are going to:<p>
<ul>
<li>Introduce the C++ interface for animats</li><li>Derive a new, moving animat from the Animat base class</li><li>Play with some very simple emergent behaviour</li></ul>
<p>
First of all, here's a (very) cut down version of the animati's C++ interface, contained in header file <a class="el" href="animat_8h.html">animat.h</a>:<p>
<div class="fragment"><pre><span class="keyword">class </span>Animat : <span class="keyword">public</span> WorldObject
{
<span class="keyword">public</span>:
    Animat();
    ~Animat();
    <span class="keyword">virtual</span> <span class="keywordtype">void</span>    Init();
    <span class="keywordtype">void</span>            Add(std::string name, Sensor* s);

    <span class="keyword">virtual</span> <span class="keywordtype">void</span>    Control(){}

    <span class="keyword">virtual</span> <span class="keywordtype">void</span>    OnCollision(WorldObject* r){}

<span class="keyword">protected</span>:
    SensorContainer sensors;
    ToolContainer tools;
    ControlContainer controls;

    Vector2D        velocity;
    <span class="keywordtype">int</span>             maximumSpeed;
    <span class="keywordtype">double</span>          maxRotateSpeed;
};
</pre></div><p>
As you can see, Animat is derived from WorldObject, which itself is derived from Drawable, so to really understand what the Animat class is and isn’t for, we need a quick overview of Drawable and WorldObject.<p>
Drawable is a base class for anything in the World which you see on the screen, so animats, obstacles and objects in the world, and also display features such as collision dots, animat trails and sensor output are all derived from Drawable. The only features of Drawable important here are:<p>
<div class="fragment"><pre>    <span class="keyword">virtual</span> <span class="keywordtype">void</span>    Init();

    Vector2D            location;
    <span class="keywordtype">double</span>              orientation;
</pre></div><p>
The location of objects is stored as a vector from the bottom left corner of the screen, so location is really just x,y coordinates. The orientation, as with all orientations in the program, is in radians going anti-clockwise and counting from east. Init is called at the start of a simulation and gives the object the chance to set itself up.<p>
WorldObject is derived from Drawable and is the base class for everything involved in simulations - animats, obstacles and other objects (but not collision dots, trails or other display features which are purely Drawable). WorldObject provides features such as collision detection, and lifecycle methods such as Update which is called at the start of each frame and is where the animat does most of its ‘thinking’ and moving, usually dependent on sensor outputs, but we'll be looking at how animats are controlled in more detail later.<p>
Now we can look at the contents of the Animat class. Animats are mobile, so they have a vector describing their velocity. They are equipped with sensors, which come in a variety of shapes and sizes and tell them about their environment, and tools, which let them manipulate their environment. The ControlContainer is really just a series of real values, the first two of which control the left and right wheels. This two-wheel approach works a little like tracks on a tank and gives the animat a full range of movement from as few inputs as possible. The sensors, tools and controls attributes are actually maps, a class provided by C++'s Standard Template Library which works something like a vector, but lets us enumerate the contents using any type. In this case, string is used, so to set the speed of each wheel to zero, simply put:<p>
<div class="fragment"><pre>Controls[<span class="stringliteral">"left"</span>] = 0.0;
Controls[<span class="stringliteral">"right"</span>] = 0.0;
</pre></div><p>
As it is, the vanilla Animat class above won’t do anything. You could make some plain animats and put them into a simulation but they’ll just sit there. To make animats which do something, we need to derive a new class from the one provided.<h2><a name="tutorial1_1"></a>
Making Dancing Animats</h2>
We're going to make Animats which follow each other around, doing the conga. If you'd find a biological metaphor more convincing, we are going to create Musk Shrews. Juvenile Musk Shrews follow their mother around by forming a 'caravan', which is just a trail of shrews biting the tail of the shrew in front. Since shrews are born blind, this behaviour is important to their survival, and if the mother is lost, a desperate shrew at the front of a caravan will clamp on to whatever is in front of it, even if it's the back of the caravan. Although not as impressive as flocks and shoals, this is still a simple form of emergent behaviour: by following a simple rule, "follow the nearest shrew in front of you", shrews produce the more complex behaviour of forming caravans.<p>
Our shrew will be a simple two-sensor animat, wired up like a Braitenburg vehicle with two sensors each driving the opposite wheel. The file we're about to write will be a .cc file, called something like 'shrew.cc'.<p>
First of all, we need to include the interface header:<p>
<div class="fragment"><pre><span class="preprocessor">#include "wxsimenv.h"</span>
</pre></div><p>
And also the header for the Animat class, and the header for sensors:<p>
<div class="fragment"><pre><span class="preprocessor">#include "<a class="code" href="animat_8h.html">animat.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="sensor_8h.html">sensor.h</a>"</span>
</pre></div><p>
Next we specify the namespace, GASimEnv. Everything in the simulation environment resides within this namespace.<p>
<div class="fragment"><pre><span class="keyword">using</span> <span class="keyword">namespace </span>GASimEnv;
</pre></div><p>
Now to create our new animat, which will be called <code>Shrew</code>. The whole definition for the class is below, including all methods.<p>
<div class="fragment"><pre><span class="keyword">class </span>Shrew : <span class="keyword">public</span> Animat <span class="comment">// Shrew is derived from Animat</span>
{
<span class="keyword">public</span>:
    Shrew()
    {
        This.Add(<span class="stringliteral">"left"</span>, ProximitySensor&lt;Shrew&gt;(PI/5, 200.0, -PI/20));
        This.Add(<span class="stringliteral">"right"</span>, ProximitySensor&lt;Shrew&gt;(PI/5, 200.0, PI/20));

        This.InitRandom = <span class="keyword">true</span>;     <span class="comment">// Start in random locations</span>

        This.Radius = 10.0;         <span class="comment">// Shrews are a little bigger than usual</span>
    }
    <span class="keyword">virtual</span> ~Shrew(){}

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Control()
    {
        This.Controls[<span class="stringliteral">"left"</span>] = This.Sensors[<span class="stringliteral">"right"</span>]-&gt;GetOutput();
        This.Controls[<span class="stringliteral">"right"</span>] = This.Sensors[<span class="stringliteral">"left"</span>]-&gt;GetOutput();
    }
};
</pre></div><p>
Note that the overridden Control method has the keyword <code>virtual</code> this is important because it ensures that even though the simulation environment doesn't know whether it contains plain animats, special derived animats or a mixture, the correct control function will be selected at runtime. Without the virtual keyword, the new Control method might be ignored and the original empty one used instead.<p>
Now that we have defined the shrew, all that's left to do is set up the simulation.<p>
<div class="fragment"><pre><span class="keyword">class </span>ShrewSimulation : <span class="keyword">public</span> Simulation
{
    Group&lt;Shrew&gt; grpShrew;

<span class="keyword">public</span>:
    ShrewSimulation():
    grpShrew(30)
    {
        This.Add(<span class="stringliteral">"Shrews"</span>, grpShrew);
    }
};
</pre></div><p>
The class <code>ShrewSimulation</code> has simply been derived from <code>Simulation</code>. A data member has been added called <code>grpShrew</code>, which is a <code>Group</code> of <code>Shrews</code>. A <code>Group</code> is really just a <code>vector</code> with some additional methods for adding its contents to the <code>World</code>. <code>ShrewSimulation's</code> constructor only does two things: <code>grpShrew</code> is configured to create 30 shrews, and then the group is added to the <code>World</code> and given the name, "Shrews".<p>
Finally, we need to tell the simulation environment about the new simulation class. This is done using macros:<p>
<div class="fragment"><pre><a class="code" href="beast_8h.html#a0">BEGIN_SIMULATION_TABLE</a>
    <a class="code" href="beast_8h.html#a1">ADD_SIMULATION</a>(<span class="stringliteral">"Shrews"</span>, ShrewSimulation)
<a class="code" href="beast_8h.html#a2">END_SIMULATION_TABLE</a>
</pre></div><p>
As you can see, simulations go into a table, and it's possible to compile the simulation environment with up to ten simulations which are started from the File menu.<p>
To compile the simulation, just type (assuming the above code is saved in the file shrew.cc):<p>
make shrew<p>
And after a few moments you will be able to see your simulation in action by typing:<p>
./shrew<p>
You should then be looking at a screen full of quite confused, dancing shrew-bots.<h2><a name="tutorial1_2"></a>
More things to try</h2>
You can see from the code above how simple it is to set up sensors and to turn sensor outputs into wheel inputs. By adding more sensors you can create more complex behaviours including steering and rudimentary flocking. For inspiration, take a look at this page: <a href="http://www.red3d.com/cwr/boids/">http://www.red3d.com/cwr/boids/</a> <hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:26:34 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
