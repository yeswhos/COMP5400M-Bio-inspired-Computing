<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: DynamicalNet source code</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a name="dnncode">DynamicalNet source code</a>
</h1><div class="fragment"><pre>
<span class="preprocessor">#include "<a class="code" href="dynamicalnet_8h.html">dynamicalnet.h</a>"</span>

<span class="keyword">using</span> <span class="keyword">namespace </span>std;

<span class="keyword">namespace </span>BEAST {

DynamicalNet::DynamicalNet(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> o, <span class="keywordtype">int</span> t, <span class="keywordtype">bool</span> mi, <span class="keywordtype">bool</span> mo)
{
    <a class="code" href="classBEAST_1_1WorldObject.html#a3">Init</a>(i, o, t, mi, mo);
}

DynamicalNet::~DynamicalNet()
{
}

<span class="keywordtype">void</span> DynamicalNet::Init(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> o, <span class="keywordtype">int</span> t, <span class="keywordtype">bool</span> mi, <span class="keywordtype">bool</span> mo)
{
    inputs = vector&lt;float&gt;(i);
    outputs = vector&lt;float&gt;(o);
    neuronStates = vector&lt;float&gt;(t);
    multiInputNodes = mi;
    multiOutputNodes = mo;
    neurons.clear();

    <span class="keywordtype">int</span> neuronInputs = multiInputNodes ? i : 0,
        neuronOutputs = multiOutputNodes ? o : 0,
        neuronInChl = -1,
        neuronOutChl = -1;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; t; ++n) {
        <span class="keywordflow">if</span> (!multiInputNodes) {
            neuronInChl = n &lt; i ? n : -1;
        }
        <span class="keywordflow">if</span> (!multiOutputNodes) {
            neuronOutChl = n + (o - t);
            <span class="keywordflow">if</span> (neuronOutChl &lt; 0 || neuronOutChl &gt;= o) {
                neuronOutChl = -1;
            }
        }
        neurons.push_back(Neuron(neuronInputs, neuronOutputs, t,
                                 neuronInChl, neuronOutChl, <span class="keyword">this</span>));
    }
    Reset();
}

<span class="keywordtype">void</span> DynamicalNet::Reset()
{
    fill(neuronStates.begin(), neuronStates.end(), 0.0f);
}

<span class="keywordtype">void</span> DynamicalNet::SetInputChannel(<span class="keywordtype">int</span> neuron, <span class="keywordtype">int</span> channel)
{
    <span class="keywordflow">if</span> (multiInputNodes || channel &lt; 0 
        || channel &gt; static_cast&lt;int&gt;(inputs.size())) <span class="keywordflow">return</span>;

    vector&lt;Neuron&gt;::iterator i = neurons.begin();
    <span class="keywordflow">for</span> (; i != neurons.end(); ++i) {
        <span class="keywordflow">if</span> (i-&gt;inputChannel == channel) {
            i-&gt;inputWeights.clear();
        }
    }

    neurons[neuron].inputChannel = channel;
    neurons[neuron].inputWeights = vector&lt;float&gt;(1);
}

<span class="keywordtype">void</span> DynamicalNet::SetOutputChannel(<span class="keywordtype">int</span> neuron, <span class="keywordtype">int</span> channel)
{
    <span class="keywordflow">if</span> (multiInputNodes || channel &lt; 0 
        || channel &gt; static_cast&lt;int&gt;(outputs.size())) <span class="keywordflow">return</span>;

    vector&lt;Neuron&gt;::iterator i = neurons.begin();
    <span class="keywordflow">for</span> (; i != neurons.end(); ++i) {
        <span class="keywordflow">if</span> (i-&gt;outputChannel == channel) {
            i-&gt;outputWeights.clear();
        }
    }

    neurons[neuron].outputChannel = channel;
    neurons[neuron].outputWeights = vector&lt;float&gt;(1);
}

<span class="keywordtype">void</span> DynamicalNet::Randomise()
{
    for_each(neurons.begin(), neurons.end(), mem_fun_ref(&amp;Neuron::Randomise));
}

<span class="keywordtype">void</span> DynamicalNet::Neuron::Randomise()
{
    generate(inputWeights.begin(), inputWeights.end(), RandomNum);
    generate(outputWeights.begin(), outputWeights.end(), RandomNum);
    generate(weights.begin(), weights.end() - 1, RandomNum);
    bias = *(weights.end() - 2);
    timeConstant = <a class="code" href="group__utilities.html#a4">randval</a>(69.0f) + 1.0f;
    weights.back() = static_cast&lt;float&gt;(log(static_cast&lt;double&gt;(timeConstant)));
}

<span class="keywordtype">void</span> DynamicalNet::Fire()
{
    <span class="comment">// Clear the output values</span>
    fill(outputs.begin(), outputs.end(), 0.0f);

    <span class="comment">// Call Fire on every neuron</span>
    for_each(neurons.begin(), neurons.end(), mem_fun_ref(&amp;Neuron::Fire));

    <span class="comment">// Store the output value of each neuron for next time.</span>
    transform(neurons.begin(), neurons.end(), neuronStates.begin(), mem_fun_ref(&amp;Neuron::GetOutput));
}

<span class="keywordtype">void</span> DynamicalNet::Neuron::Fire()
{
    <span class="comment">// Start off with the negative of last round's activation.</span>
    <span class="keywordtype">float</span> deltaActivation = -activation;
    
    <span class="comment">// Add weighted sum of the other neurons' **output** values</span>
    <span class="comment">// (output value = sigmoid(activation - bias)</span>
    deltaActivation += inner_product(parent-&gt;neuronStates.begin(), 
                                     parent-&gt;neuronStates.end(),
                                     weights.begin(), 0.0f);

    <span class="comment">// Apply any input values</span>
    <span class="comment">// ... if there is no particular input channel,</span>
    <span class="keywordflow">if</span> (inputChannel == -1) {
        <span class="comment">// ... but we have input weights:</span>
        <span class="keywordflow">if</span> (!inputWeights.empty()) {
            <span class="comment">// Add a weighted sum of the current inputs and this neuron's</span>
            <span class="comment">// input weights.</span>
            deltaActivation += inner_product(parent-&gt;inputs.begin(),
                                             parent-&gt;inputs.end(),
                                             inputWeights.begin(), 0.0f);
        }
    }
    <span class="comment">// ... if only one input channel goes to this node:</span>
    <span class="keywordflow">else</span> {
        <span class="comment">// Add the unweighted input value.</span>
        deltaActivation += parent-&gt;inputs[inputChannel];
    }

    <span class="comment">// Divide by the time constant</span>
    deltaActivation /= timeConstant;

    <span class="comment">// And add to the previous activation</span>
    activation += deltaActivation;

    <span class="comment">// Bias and squash</span>
    output = Sigmoid(activation - bias);

    <span class="comment">// Send output values (if this or all neurons are output neurons)</span>
    <span class="comment">// ... if there is no particular output channel,</span>
    <span class="keywordflow">if</span> (outputChannel == -1) {
        <span class="comment">// ... but we have output weights:</span>
        <span class="keywordflow">if</span> (!outputWeights.empty()) {
            <span class="comment">// Add the neuron's output to each output channel, weighted by</span>
            <span class="comment">// the neuron's output weights.</span>
            vector&lt;float&gt;::iterator i = parent-&gt;outputs.begin(),
                                    j = outputWeights.begin();
            <span class="keywordflow">for</span> (; i != parent-&gt;outputs.end(); ++i, ++j) {
                *i += *j * output;
            }
        }
    }
    <span class="comment">// ... or for just one output neuron:</span>
    <span class="keywordflow">else</span> {
        parent-&gt;outputs[outputChannel] += output;
    }
}

vector&lt;float&gt; DynamicalNet::GetConfiguration()<span class="keyword">const</span>
{
    vector&lt;float&gt; config;
    vector&lt;Neuron&gt;::const_iterator i = neurons.begin();
    <span class="keywordflow">for</span> (; i != neurons.end(); ++i) {
        i-&gt;GetConfiguration(config);
    }

    <span class="keywordflow">return</span> config;
}

<span class="keywordtype">void</span> DynamicalNet::Neuron::GetConfiguration(vector&lt;float&gt;&amp; config)<span class="keyword">const</span>
{
    copy(inputWeights.begin(), inputWeights.end(), back_inserter(config));
    copy(outputWeights.begin(), outputWeights.end(), back_inserter(config));
    copy(weights.begin(), weights.end(), back_inserter(config));
}

<span class="keywordtype">void</span> DynamicalNet::SetConfiguration(<span class="keyword">const</span> vector&lt;float&gt;&amp; config)
{
    vector&lt;Neuron&gt;::iterator i = neurons.begin();
    vector&lt;float&gt;::const_iterator j = config.begin();

    <span class="keywordflow">do</span> {    
        j = i-&gt;SetConfiguration(j);
    } <span class="keywordflow">while</span> (++i != neurons.end());
}

vector&lt;float&gt;::const_iterator
DynamicalNet::Neuron::SetConfiguration(vector&lt;float&gt;::const_iterator config)
{
    <span class="comment">// First come the input weights...</span>
    <span class="keywordflow">if</span> (inputChannel == -1) {
        copy(config, config + inputWeights.size(), inputWeights.begin());
        config += inputWeights.size();
    }
    <span class="comment">// ... or the input weight...</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!inputWeights.empty()) {
        inputWeights.front() = *config;
        ++config;
    }

    <span class="comment">// Then the output weights...</span>
    <span class="keywordflow">if</span> (outputChannel == -1) {
        copy(config, config + outputWeights.size(), outputWeights.begin());
        config += outputWeights.size();
    }
    <span class="comment">// ... or just one output weight...</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!outputWeights.empty()) {
        outputWeights.front() = *config;
        ++config;
    }
    
    <span class="comment">// Then the remainder are the internal weights</span>
    copy(config, config + weights.size(), weights.begin());

    bias = *(weights.end() - 2);
    timeConstant = static_cast&lt;float&gt;(exp(static_cast&lt;double&gt;(weights.back())));

    <span class="keywordflow">if</span> (timeConstant &lt; 1.0f) {
        timeConstant = 1.0f + 2 * (1.0f - timeConstant);
        weights.back() = static_cast&lt;float&gt;(log(static_cast&lt;double&gt;(timeConstant)));
    }

    <span class="keywordflow">return</span> config + weights.size();
}

<span class="keywordtype">void</span> DynamicalNet::Serialise(ostream&amp; out)<span class="keyword">const</span>
{
    out &lt;&lt; <span class="stringliteral">"DynamicalNet\n"</span>
        &lt;&lt; setprecision(36)
        &lt;&lt; static_cast&lt;int&gt;(inputs.size()) &lt;&lt; endl
        &lt;&lt; static_cast&lt;int&gt;(outputs.size()) &lt;&lt; endl
        &lt;&lt; static_cast&lt;int&gt;(neurons.size()) &lt;&lt; endl
        &lt;&lt; (multiInputNodes ? <span class="stringliteral">"multi_in"</span> : <span class="stringliteral">"single_in"</span>) &lt;&lt; endl
        &lt;&lt; (multiOutputNodes ? <span class="stringliteral">"multi_out"</span> : <span class="stringliteral">"single_out"</span>) &lt;&lt; endl;

    vector&lt;float&gt; config = GetConfiguration();
    copy(config.begin(), config.end(), ostream_iterator&lt;float&gt;(out, <span class="stringliteral">"\n"</span>));
}

<span class="keywordtype">void</span> DynamicalNet::Unserialise(istream&amp; in)
{
    string name;
    in &gt;&gt; name;
    <span class="keywordflow">if</span> (name != <span class="stringliteral">"DynamicalNet"</span>) {
        <span class="keywordflow">throw</span> SerialException(SERIAL_ERROR_WRONG_TYPE, name, 
                              <span class="stringliteral">"This object is type DynamicalNet"</span>);
    }

    <span class="keywordtype">int</span> i, o, t;
    <span class="keywordtype">bool</span> mi, mo;

    in &gt;&gt; i &gt;&gt; o &gt;&gt; t &gt;&gt; switcher(<span class="stringliteral">"multi_in"</span>, mi) &gt;&gt; switcher(<span class="stringliteral">"multi_out"</span>, mo);
    <a class="code" href="classBEAST_1_1WorldObject.html#a3">Init</a>(i, o, t, mi, mo);

    vector&lt;float&gt; config(GetConfigurationLength());
    <a class="code" href="group__serialisation.html#a4">copy_from_istream</a>(config.begin(), config.end(), in); 
    SetConfiguration(config);
}

string DynamicalNet::ToString()<span class="keyword">const</span>
{
    ostringstream out;
    ostream_iterator&lt;float&gt; outIter(out, <span class="stringliteral">" "</span>);

    out &lt;&lt; <span class="stringliteral">"Input values:"</span> &lt;&lt; endl;
    copy(inputs.begin(), inputs.end(), outIter);
    out &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Output values:"</span> &lt;&lt; endl;
    copy(outputs.begin(), outputs.end(), outIter);
    out &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Activation states:"</span> &lt;&lt; endl;
    copy(neuronStates.begin(), neuronStates.end(), outIter);
    out &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Neurons:"</span> &lt;&lt; endl;
    transform(neurons.begin(), neurons.end(), 
              ostream_iterator&lt;string&gt;(out, <span class="stringliteral">"\n"</span>),
              mem_fun_ref(&amp;Neuron::ToString));
    out &lt;&lt; endl;

    <span class="keywordflow">return</span> out.str();
}

string DynamicalNet::Neuron::ToString()<span class="keyword">const</span>
{
    ostringstream out;
    ostream_iterator&lt;float&gt; outIter(out, <span class="stringliteral">" "</span>);
    
    <span class="keywordflow">if</span> (!inputWeights.empty()) {
        out &lt;&lt; <span class="stringliteral">"Input weight(s):"</span> &lt;&lt; endl;
        copy(inputWeights.begin(), inputWeights.end(), outIter);
        out &lt;&lt; endl;
    }
    out &lt;&lt; <span class="stringliteral">"Hidden layer weight(s):"</span> &lt;&lt; endl;
    copy(weights.begin(), weights.end() - 2, outIter);
    out &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Bias: "</span> &lt;&lt; bias &lt;&lt; <span class="stringliteral">" Time constant: "</span> &lt;&lt; timeConstant
        &lt;&lt; endl;
    <span class="keywordflow">if</span> (!outputWeights.empty()) {
        out &lt;&lt; <span class="stringliteral">"Output weight(s):"</span> &lt;&lt; endl;
        copy(outputWeights.begin(), outputWeights.end(), outIter);
        out &lt;&lt; endl;
    }
    
    <span class="keywordflow">return</span> out.str();
}

<span class="keywordtype">int</span> DynamicalNet::GetConfigurationLength()<span class="keyword">const</span>
{
    <span class="keywordtype">int</span> numNeurons = static_cast&lt;int&gt;(neurons.size()),
        numInputs  = static_cast&lt;int&gt;(inputs.size()),
        numOutputs = static_cast&lt;int&gt;(outputs.size());

    <span class="keywordflow">return</span> numNeurons * numNeurons
        + (multiInputNodes ? numNeurons * numInputs : 0)
        + (multiOutputNodes ? numNeurons * numOutputs : 0);
}

ostream&amp; <a class="code" href="group__biosystems.html#a2">operator&lt;&lt;</a>(ostream&amp; out, <span class="keyword">const</span> DynamicalNet&amp; dnn)
{
    dnn.Serialise(out);
    <span class="keywordflow">return</span> out;
}

istream&amp; <a class="code" href="group__biosystems.html#a3">operator&gt;&gt;</a>(istream&amp; in, DynamicalNet&amp; dnn)
{
    dnn.Unserialise(in);
    <span class="keywordflow">return</span> in;
}

} <span class="comment">// namespace BEAST</span>
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:26:30 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
