<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: BEAST Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>BEAST Namespace Reference</h1>The namespace for everything in the simulation environment.  
<a href="#_details">More...</a>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Animat.html">Animat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Animats can move around and interact with other objects in the world. </em> <a href="classBEAST_1_1Animat.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>AnimatMonitor</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1AreaSensor.html">AreaSensor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detects objects within an area specified by the size and shape of the <a class="el" href="classBEAST_1_1AreaSensor.html">AreaSensor</a>. </em> <a href="classBEAST_1_1AreaSensor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>auto_indexed_pointer_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>auto_indexed_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>auto_pointer_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>auto_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Bacterium.html">Bacterium</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1BeamSensor.html">BeamSensor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BeamSensors can really be three distinct kinds of sensor: Lasers, which just detect objects a certain distance away in a straight line from the sensor's origin. </em> <a href="classBEAST_1_1BeamSensor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A functor which creates a unary function from a unary member function, binding an instance of the class to which the function belongs. </em> <a href="structBEAST_1_1bound__mem__fun__t.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1call__on__mem__t.html">call_on_mem_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows us to bind functors so that they work on particular members of classes, useful for using for_each on maps. </em> <a href="classBEAST_1_1call__on__mem__t.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>Collisions</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1creator.html">creator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A functor for use with the for_each algorithm which can perform creation of objects when called on a container of pointers. </em> <a href="structBEAST_1_1creator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1deleter.html">deleter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A functor for use with the for_each algorithm which can perform deletion of objects when called on a container of pointers. </em> <a href="structBEAST_1_1deleter.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Distribution.html">Distribution</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements a grid which stores spatial density information to a specified resolution, e.g. </em> <a href="classBEAST_1_1Distribution.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1Distribution_1_1Kernel.html">Distribution::Kernel</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements diffusion and other neighbourhood operations. </em> <a href="structBEAST_1_1Distribution_1_1Kernel.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1DNNAnimat.html">DNNAnimat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="classBEAST_1_1Animat.html">Animat</a> with a built-in dynamical network which is automatically configured depending on the Animat's sensor and control configuration. </em> <a href="classBEAST_1_1DNNAnimat.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>Drawable</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1DynamicalNet.html">DynamicalNet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class implements a fully recurrent continuous (or dynamical) neural network. </em> <a href="classBEAST_1_1DynamicalNet.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1DynamicalNet_1_1Neuron.html">DynamicalNet::Neuron</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlike the <a class="el" href="classBEAST_1_1FeedForwardNet.html">FeedForwardNet</a>, the <a class="el" href="structBEAST_1_1DynamicalNet_1_1Neuron.html">Neuron</a> in <a class="el" href="classBEAST_1_1DynamicalNet.html">DynamicalNet</a> is more worthy of its name, since nearly all the processing of the DNN's firing algorithm occurs here. </em> <a href="structBEAST_1_1DynamicalNet_1_1Neuron.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>EvalCount</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>EvalDensity</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>EvalGradient</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvalNearest.html">EvalNearest</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keeps a tally of the nearest point passed in and returns it with GetOutput. </em> <a href="classBEAST_1_1EvalNearest.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvalNearestAbsX.html">EvalNearestAbsX</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute x position of the nearest target. </em> <a href="classBEAST_1_1EvalNearestAbsX.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvalNearestAbsY.html">EvalNearestAbsY</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute y position of the nearest target. </em> <a href="classBEAST_1_1EvalNearestAbsY.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvalNearestAngle.html">EvalNearestAngle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the normalised angle to the nearest target. </em> <a href="classBEAST_1_1EvalNearestAngle.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvalNearestSignal.html">EvalNearestSignal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> evaluation functor: returns the signal of the nearest individual. </em> <a href="classBEAST_1_1EvalNearestSignal.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvalNearestXDist.html">EvalNearestXDist</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the vertical distance to the nearest target. </em> <a href="classBEAST_1_1EvalNearestXDist.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvalNearestYDist.html">EvalNearestYDist</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the horizontal distance to the nearest target. </em> <a href="classBEAST_1_1EvalNearestYDist.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvoDNNAnimat.html">EvoDNNAnimat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An evolvable version of <a class="el" href="classBEAST_1_1DNNAnimat.html">DNNAnimat</a> with GetGenotype/SetGenotype methods already set up. </em> <a href="classBEAST_1_1EvoDNNAnimat.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1EvoFFNAnimat.html">EvoFFNAnimat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An evolvable version of <a class="el" href="classBEAST_1_1FFNAnimat.html">FFNAnimat</a> with GetGenotype/SetGenotype methods already set up. </em> <a href="classBEAST_1_1EvoFFNAnimat.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Evolver.html">Evolver</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1extractor.html">extractor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a function object which can be used for copying from an iterator when the number of input values is unknown. </em> <a href="structBEAST_1_1extractor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1FeedForwardNet.html">FeedForwardNet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an implementation of a simple two-layer feed-forward neural network. </em> <a href="classBEAST_1_1FeedForwardNet.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1FeedForwardNet_1_1Neuron.html">FeedForwardNet::Neuron</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This member struct simply encapsulates the weighted sum function which has to be performed on the weights of each node when the net fires. </em> <a href="structBEAST_1_1FeedForwardNet_1_1Neuron.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1FFNAnimat.html">FFNAnimat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An <a class="el" href="classBEAST_1_1Animat.html">Animat</a> with a built-in feed-forward network which is automatically configured depending on the Animat's sensor and control configuration. </em> <a href="classBEAST_1_1FFNAnimat.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1Gaussian2D.html">Gaussian2D</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots a two-dimensional Gaussian function in a distribution or distribution kernel. </em> <a href="structBEAST_1_1Gaussian2D.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1GaussianNoise.html">GaussianNoise</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots normally distributed noise in a distribution. </em> <a href="structBEAST_1_1GaussianNoise.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1GaussianRing2D.html">GaussianRing2D</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots a two dimensional Gaussian ring. </em> <a href="structBEAST_1_1GaussianRing2D.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1GAVariant.html">GAVariant</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a general purpose data type which takes five basic data types: int, float, double, char and bool. </em> <a href="structBEAST_1_1GAVariant.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>union &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="unionBEAST_1_1GAVariant_1_1VariantData.html">GAVariant::VariantData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Union of five data types for <a class="el" href="structBEAST_1_1GAVariant.html">GAVariant</a>. </em> <a href="unionBEAST_1_1GAVariant_1_1VariantData.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1GeneticAlgorithm.html">GeneticAlgorithm</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classBEAST_1_1GeneticAlgorithm.html">GeneticAlgorithm</a> class provides functionality to cover a range of GA methods, and may be extended to incorporate other approaches. </em> <a href="classBEAST_1_1GeneticAlgorithm.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1GeneticAlgorithm_1_1evo__sort.html">GeneticAlgorithm::evo_sort</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A little function object to enable us to sort the population by fitness. </em> <a href="structBEAST_1_1GeneticAlgorithm_1_1evo__sort.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>GetSimulation</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>GetSimulationBase</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Group.html">Group</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple class which creates and maintains a vector of objects of the specified type and adds them to the world each round. </em> <a href="classBEAST_1_1Group.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>LimitDistribution</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MatchAdapter.html">MatchAdapter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows any unary predicate to be adapted for use as a matching function. </em> <a href="structBEAST_1_1MatchAdapter.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MatchComposeAnd.html">MatchComposeAnd</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chains any number of matching functions together such that only if all of them are true for the object being matched, <a class="el" href="structBEAST_1_1MatchComposeAnd.html">MatchComposeAnd</a> will return true. </em> <a href="structBEAST_1_1MatchComposeAnd.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MatchComposeOr.html">MatchComposeOr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chains any number of matching functions together such that should any of them be true for the object being matched, <a class="el" href="structBEAST_1_1MatchComposeOr.html">MatchComposeOr</a> will return true. </em> <a href="structBEAST_1_1MatchComposeOr.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MatchExact.html">MatchExact</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies exact object types, so if defined with Cheese, will return true only for Cheese, and false for Cheddar and Gruyère. </em> <a href="structBEAST_1_1MatchExact.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MatchKindOf.html">MatchKindOf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies objects belonging to hierarchies, so if defined with Cheese, will return true for objects of type Cheese, or derived classes such as Cheddar and Gruyère. </em> <a href="structBEAST_1_1MatchKindOf.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MatchSpecific.html">MatchSpecific</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies one particular object and returns true only for that object. </em> <a href="structBEAST_1_1MatchSpecific.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MutationOperator_3_01bool_01_4.html">MutationOperator&lt; bool &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialised <a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a> for bool, simply NOT's its input. </em> <a href="structBEAST_1_1MutationOperator_3_01bool_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1MutationOperator_3_01GAVariant_01_4.html">MutationOperator&lt; GAVariant &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This specialised mutation operator provides the facilities of the basic <a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a> for <a class="el" href="structBEAST_1_1GAVariant.html">GAVariant</a>. </em> <a href="structBEAST_1_1MutationOperator_3_01GAVariant_01_4.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>NormalMutator</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ObjLoader.html">ObjLoader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A functor for recreating templated object types using serialisation. </em> <a href="structBEAST_1_1ObjLoader.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ObjLoaderBase.html">ObjLoaderBase</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple abstract base class for <a class="el" href="structBEAST_1_1ObjLoader.html">ObjLoader</a> functors. </em> <a href="structBEAST_1_1ObjLoaderBase.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>pointer_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Population.html">Population</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is derived from <a class="el" href="classBEAST_1_1Group.html">Group</a> and adds a managed GA which is automatically run on the whole <a class="el" href="classBEAST_1_1Population.html">Population</a> every epoch. </em> <a href="classBEAST_1_1Population.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>Population::Clone</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by <a class="el" href="classBEAST_1_1Population.html">Population</a> to create a clone of an individual. </em> <a href="structBEAST_1_1Population_1_1Clone.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>Population::UnClone</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merges two individuals such that the resulting individual's fitness scores will contain all the scores of both individuals. </em> <a href="structBEAST_1_1Population_1_1UnClone.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1property.html">property</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class wrapper for a member variable which allows member data to be exposed with invisible get/set semantics. </em> <a href="classBEAST_1_1property.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>PSOAlgorithm</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1Ring2D.html">Ring2D</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots a two dimensional ring. </em> <a href="structBEAST_1_1Ring2D.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ScaleAbs.html">ScaleAbs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute value of the input, as for the std::abs function. </em> <a href="structBEAST_1_1ScaleAbs.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ScaleAdapter.html">ScaleAdapter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows any unary functor to be adapted for use as a scaling function. </em> <a href="structBEAST_1_1ScaleAdapter.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ScaleCompose.html">ScaleCompose</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structBEAST_1_1ScaleCompose.html">ScaleCompose</a> allows the chaining of two scaling functions together, such the output of a <a class="el" href="structBEAST_1_1ScaleCompose.html">ScaleCompose</a> functor is the result of second(first(input)), where first and second are the arguments in ScaleCompose's constructor. </em> <a href="structBEAST_1_1ScaleCompose.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>ScaleGradient</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ScaleLinear.html">ScaleLinear</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple linear scaling function which defaults to an input scale between 0 and a defined maximum, scaling to an output range between 0 and 1. </em> <a href="structBEAST_1_1ScaleLinear.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ScaleNoise.html">ScaleNoise</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structBEAST_1_1ScaleNoise.html">ScaleNoise</a> adds uniform random noise to its input. </em> <a href="structBEAST_1_1ScaleNoise.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1ScaleThreshold.html">ScaleThreshold</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structBEAST_1_1ScaleThreshold.html">ScaleThreshold</a> takes values: threshold, min and max and returns min if input &lt; threshold, or max if input &gt;= threshold. </em> <a href="structBEAST_1_1ScaleThreshold.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1SelfSensor.html">SelfSensor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classBEAST_1_1SelfSensor.html">SelfSensor</a> is used to detect information about its owner. </em> <a href="classBEAST_1_1SelfSensor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Sensor.html">Sensor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> class is the base class for all the different types of sensor: <a class="el" href="classBEAST_1_1TouchSensor.html">TouchSensor</a>, <a class="el" href="classBEAST_1_1SelfSensor.html">SelfSensor</a>, <a class="el" href="classBEAST_1_1AreaSensor.html">AreaSensor</a> and <a class="el" href="classBEAST_1_1BeamSensor.html">BeamSensor</a>. </em> <a href="classBEAST_1_1Sensor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1SensorEvalFunction.html">SensorEvalFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for evaluation functors. </em> <a href="structBEAST_1_1SensorEvalFunction.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1SensorMatchFunction.html">SensorMatchFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for matching functors. </em> <a href="structBEAST_1_1SensorMatchFunction.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1SensorScaleFunction.html">SensorScaleFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for scaling functors. </em> <a href="structBEAST_1_1SensorScaleFunction.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1SerialException.html">SerialException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Since exceptions have an undesirable overhead, they have not been used elsewhere in the simulation environment for reasons of speed. </em> <a href="structBEAST_1_1SerialException.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Signaller.html">Signaller</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A general-purpose class for modelling signallers with discrete signal and state types. </em> <a href="classBEAST_1_1Signaller.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1SimObject.html">SimObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An abstract base class for the <a class="el" href="classBEAST_1_1Population.html">Population</a> template, allowing populations with different templated types to be represented in <a class="el" href="classBEAST_1_1Simulation.html">Simulation</a>. </em> <a href="classBEAST_1_1SimObject.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Simulation.html">Simulation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The basic <a class="el" href="classBEAST_1_1Simulation.html">Simulation</a> framework which must be derived to set up simulations. </em> <a href="classBEAST_1_1Simulation.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1switcher.html">switcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The switcher is useful when configuring bools from string data. </em> <a href="structBEAST_1_1switcher.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1TouchSensor.html">TouchSensor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detects objects which are touching the sensor's owner. </em> <a href="classBEAST_1_1TouchSensor.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>Trail</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1UniformNoise.html">UniformNoise</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots uniform noise in a distribution. </em> <a href="structBEAST_1_1UniformNoise.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Unserialiser.html">Unserialiser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is available for unserialising objects from streams, without knowing which type of object is to be unserialised - the type is determined from the header of the stream. </em> <a href="classBEAST_1_1Unserialiser.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Vector2D.html">Vector2D</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A class for representing two-dimensional vectors and coordinates. </em> <a href="classBEAST_1_1Vector2D.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1Wall.html">Wall</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a handy class for putting the most common type of obstacle - walls - into the world. </em> <a href="classBEAST_1_1Wall.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1World.html">World</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is where it all happens: <a class="el" href="classBEAST_1_1World.html">World</a> contains pointers to every object in the simulation environment and allows those objects to interact with each other, and then be displayed. </em> <a href="classBEAST_1_1World.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>World::DisplayInfo</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>World::PointerInfo</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1WorldObject.html">WorldObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class for everything that makes a difference in the world, including Animats, Sensors and all types of scenery and interactive object. </em> <a href="classBEAST_1_1WorldObject.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><b>ZeroDistribution</b></td></tr>

<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="BEAST::DistReal"></a>
typedef float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__bacteria.html#a0">DistReal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For speed, Distributions use floats but this typedef makes it possible to switch to doubles if higher accuracy is required. <br><br></td></tr>
<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a20">AnimatPartType</a> { <b>ANIMAT_BODY</b>, 
<b>ANIMAT_CENTRE</b>, 
<b>ANIMAT_ARROW</b>, 
<b>ANIMAT_WHEEL</b>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration type for the different coloured parts of the Animat. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a33">ColourType</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__utilities.html#a33a15">COLOUR_BLACK</a>, 
<a class="el" href="group__utilities.html#a33a16">COLOUR_WHITE</a>, 
<a class="el" href="group__utilities.html#a33a17">COLOUR_GREEN</a>, 
<a class="el" href="group__utilities.html#a33a18">COLOUR_BLUE</a>, 
<br>
&nbsp;&nbsp;<b>COLOUR_RED</b>, 
<b>COLOUR_PURPLE</b>, 
<b>COLOUR_DARK_PURPLE</b>, 
<b>COLOUR_YELLOW</b>, 
<br>
&nbsp;&nbsp;<b>COLOUR_LILAC</b>, 
<b>COLOUR_BROWN</b>, 
<b>COLOUR_LIGHT_GREY</b>, 
<b>COLOUR_DARK_GREY</b>, 
<br>
&nbsp;&nbsp;<b>COLOUR_MID_GREY</b>, 
<b>COLOUR_ORANGE</b>, 
<b>COLOUR_PINK</b>, 
<b>COLOUR_SELECTION</b>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An enumeration type for colours. </em> <a href="group__utilities.html#a33">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a13">GASelectionType</a> { <a class="el" href="group__biosystems.html#a13a34">GA_ROULETTE</a> =  0, 
<a class="el" href="group__biosystems.html#a13a35">GA_RANK</a>, 
<a class="el" href="group__biosystems.html#a13a36">GA_TOURNAMENT</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The different options for selection are enumerated here. </em> <a href="group__biosystems.html#a13">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a14">GAFltParamType</a> { <a class="el" href="group__biosystems.html#a14a37">GA_TOURNAMENT_PARAM</a>, 
<a class="el" href="group__biosystems.html#a14a38">GA_RANK_SPRESSURE</a>, 
<a class="el" href="group__biosystems.html#a14a39">GA_EXPONENT</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assorted float parameters, set using GeneticAlgorithm::SetParameter. </em> <a href="group__biosystems.html#a14">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a15">GAIntParamType</a> { <a class="el" href="group__biosystems.html#a15a40">GA_TOURNAMENT_SIZE</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assorted integer parameters, set using GeneticAlgorithm::SetParameter. </em> <a href="group__biosystems.html#a15">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a16">GAPrintStyleType</a> { <a class="el" href="group__biosystems.html#a16a41">GA_PARAMETERS</a> =  1, 
<a class="el" href="group__biosystems.html#a16a42">GA_CURRENT</a> =  2, 
<a class="el" href="group__biosystems.html#a16a43">GA_GENERATION</a> =  4, 
<a class="el" href="group__biosystems.html#a16a44">GA_HISTORY</a> =  8
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use to set the printing style when using GA's &lt;&lt; operator. </em> <a href="group__biosystems.html#a16">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a17">GAFitnessMethodType</a> { <a class="el" href="group__biosystems.html#a17a45">GA_BEST_FITNESS</a>, 
<a class="el" href="group__biosystems.html#a17a46">GA_WORST_FITNESS</a>, 
<a class="el" href="group__biosystems.html#a17a47">GA_MEAN_FITNESS</a>, 
<a class="el" href="group__biosystems.html#a17a48">GA_TOTAL_FITNESS</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The method by which fitness is decided when individuals have multiple scores. </em> <a href="group__biosystems.html#a17">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a18">GAFitnessFixType</a> { <a class="el" href="group__biosystems.html#a18a49">GA_IGNORE</a>, 
<a class="el" href="group__biosystems.html#a18a50">GA_CLAMP</a>, 
<a class="el" href="group__biosystems.html#a18a51">GA_FIX</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the method by which fitness scores are adjusted before selection. </em> <a href="group__biosystems.html#a18">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a19">GAVariantType</a> { <br>
&nbsp;&nbsp;<b>GAV_INT</b>, 
<b>GAV_FLOAT</b>, 
<b>GAV_DOUBLE</b>, 
<b>GAV_CHAR</b>, 
<br>
&nbsp;&nbsp;<b>GAV_BOOL</b>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A type flag for the GAVariant data type. </em> <a href="group__biosystems.html#a19">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sensors.html#a12">SelfSensorType</a> { <a class="el" href="group__sensors.html#a12a61">SELF_SENSOR_X</a>, 
<a class="el" href="group__sensors.html#a12a62">SELF_SENSOR_Y</a>, 
<a class="el" href="group__sensors.html#a12a63">SELF_SENSOR_ANGLE</a>, 
<a class="el" href="group__sensors.html#a12a64">SELF_SENSOR_CONTROL</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An enumeration type for SelfSensor, used to specify which feature of the sensor's owner is to be returned by GetOutput(). </em> <a href="group__sensors.html#a12">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a17">SerialErrorType</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__serialisation.html#a17a65">SERIAL_ERROR_UNKNOWN</a>, 
<a class="el" href="group__serialisation.html#a17a66">SERIAL_ERROR_BAD_FILE</a>, 
<a class="el" href="group__serialisation.html#a17a67">SERIAL_ERROR_WRONG_TYPE</a>, 
<a class="el" href="group__serialisation.html#a17a68">SERIAL_ERROR_UNKNOWN_TYPE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__serialisation.html#a17a69">SERIAL_ERROR_DATA_MISMATCH</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerates the different types of errors encountered in serialisation. </em> <a href="group__serialisation.html#a17">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a21">SimPrintStyleType</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__framework.html#a21a70">SIM_PRINT_STATUS</a>, 
<a class="el" href="group__framework.html#a21a71">SIM_PRINT_ASSESSMENT</a>, 
<a class="el" href="group__framework.html#a21a72">SIM_PRINT_GENERATION</a>, 
<a class="el" href="group__framework.html#a21a73">SIM_PRINT_RUN</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__framework.html#a21a74">SIM_PRINT_COMPLETE</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used in Simulation::ToString to specify what is to be output. </em> <a href="group__framework.html#a21">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a22">WorldDisplayType</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__framework.html#a22a78">DISPLAY_NONE</a> =  0, 
<a class="el" href="group__framework.html#a22a79">DISPLAY_ANIMATS</a> =  1, 
<a class="el" href="group__framework.html#a22a80">DISPLAY_WORLDOBJECTS</a> =  2, 
<a class="el" href="group__framework.html#a22a81">DISPLAY_TRAILS</a> =  4, 
<br>
&nbsp;&nbsp;<a class="el" href="group__framework.html#a22a82">DISPLAY_SENSORS</a> =  8, 
<a class="el" href="group__framework.html#a22a83">DISPLAY_COLLISIONS</a> =  16, 
<a class="el" href="group__framework.html#a22a84">DISPLAY_MONITOR</a> =  32, 
<a class="el" href="group__framework.html#a22a85">DISPLAY_ALL</a> =  65535
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An enumeration type for specifying which elements of the world are to be displayed. </em> <a href="group__framework.html#a22">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="BEAST::GradientSensor"></a>
<a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><b>GradientSensor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="BEAST::DistributionSensor"></a>
<a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><b>DistributionSensor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a14" doxytag="BEAST::operator<<"></a>
ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><b>operator&lt;&lt;</b> (ostream &amp;out, const Drawable &amp;d)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a15" doxytag="BEAST::operator>>"></a>
istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><b>operator&gt;&gt;</b> (istream &amp;in, Drawable &amp;d)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a2">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classBEAST_1_1DynamicalNet.html">DynamicalNet</a> &amp;dnn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An output operator for <a class="el" href="classBEAST_1_1DynamicalNet.html">DynamicalNet</a>. </em> <a href="group__biosystems.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a3">operator&gt;&gt;</a> (istream &amp;in, <a class="el" href="classBEAST_1_1DynamicalNet.html">DynamicalNet</a> &amp;dnn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An input operator for <a class="el" href="classBEAST_1_1DynamicalNet.html">DynamicalNet</a>. </em> <a href="group__biosystems.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a4">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classBEAST_1_1FeedForwardNet.html">FeedForwardNet</a> &amp;ffn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator overload for the <a class="el" href="classBEAST_1_1FeedForwardNet.html">FeedForwardNet</a>. </em> <a href="group__biosystems.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a5">operator&gt;&gt;</a> (istream &amp;in, <a class="el" href="classBEAST_1_1FeedForwardNet.html">FeedForwardNet</a> &amp;ffn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input operator overload for the <a class="el" href="classBEAST_1_1FeedForwardNet.html">FeedForwardNet</a>. </em> <a href="group__biosystems.html#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespaceBEAST.html#a96">add_slashes</a> (const string &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces spaces with underscores and adds backslashes to other characters which might be interpreted as white space by an input stream. </em> <a href="#a96"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespaceBEAST.html#a97">strip_slashes</a> (const string &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the slashes added by add_slashes and reinstates the original string. </em> <a href="#a97"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespaceBEAST.html#a98">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classBEAST_1_1SimObject.html">SimObject</a> &amp;obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An output operator for all classes derived from <a class="el" href="classBEAST_1_1SimObject.html">SimObject</a>. </em> <a href="#a98"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="namespaceBEAST.html#a99">operator&gt;&gt;</a> (istream &amp;in, <a class="el" href="classBEAST_1_1SimObject.html">SimObject</a> &amp;obj)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An input operator for all classes derived from <a class="el" href="classBEAST_1_1SimObject.html">SimObject</a>. </em> <a href="#a99"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="BEAST::random_colour"></a>
const float *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a1">random_colour</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random colour, all set for input to glColour4fv. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a6">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a>&lt; T &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for the <a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a> function object. </em> <a href="group__biosystems.html#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a7">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a>&lt; T &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input operator for the <a class="el" href="structBEAST_1_1MutationOperator.html">MutationOperator</a> function object. </em> <a href="group__biosystems.html#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a8" doxytag="BEAST::operator<<"></a>
template&lt;class EVO, class MUTFUNC&gt; std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a8">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classBEAST_1_1GeneticAlgorithm.html">GeneticAlgorithm</a>&lt; EVO, MUTFUNC &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The GA's output operator. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="BEAST::operator>>"></a>
template&lt;class EVO, class MUTFUNC&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a9">operator&gt;&gt;</a> (std::istream &amp;, const <a class="el" href="classBEAST_1_1GeneticAlgorithm.html">GeneticAlgorithm</a>&lt; EVO, MUTFUNC &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The GA's input operator. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="BEAST::operator>>"></a>
template&lt;class EVO, class MUTFUNC&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><b>operator&gt;&gt;</b> (std::istream &amp;in, <a class="el" href="classBEAST_1_1GeneticAlgorithm.html">GeneticAlgorithm</a>&lt; EVO, MUTFUNC &gt; &amp;ga)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="BEAST::operator<<"></a>
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structBEAST_1_1GAVariant.html">GAVariant</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="BEAST::operator>>"></a>
std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><b>operator&gt;&gt;</b> (std::istream &amp;in, <a class="el" href="structBEAST_1_1GAVariant.html">GAVariant</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a108" doxytag="BEAST::glut_start_simulation"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><b>glut_start_simulation</b> (int &amp;args, char *argv[], <a class="el" href="classBEAST_1_1Simulation.html">Simulation</a> *pTheSim)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sensors.html#a4">ProximitySensor</a> (double scope, double range, double orientation)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a segment-shaped sensor with the specified scope, range and orientation which detects the distance of objects of the specified templated type. </em> <a href="group__sensors.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a5" doxytag="BEAST::NearestAngleSensor"></a>
template&lt;class T&gt; <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><b>NearestAngleSensor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a6" doxytag="BEAST::NearestXSensor"></a>
template&lt;class T&gt; <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><b>NearestXSensor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a7" doxytag="BEAST::NearestYSensor"></a>
template&lt;class T&gt; <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><b>NearestYSensor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a8" doxytag="BEAST::DensitySensor"></a>
template&lt;class T&gt; <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><b>DensitySensor</b> (double scope, double range, double orientation)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="BEAST::CollisionSensor"></a>
template&lt;class T&gt; <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><b>CollisionSensor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="BEAST::MatchAdapt"></a>
template&lt;class _Functor&gt; <a class="el" href="structBEAST_1_1MatchAdapter.html">MatchAdapter</a>&lt; _Functor &gt; *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sensors.html#a10">MatchAdapt</a> (_Functor f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper function for creating <a class="el" href="structBEAST_1_1MatchAdapter.html">MatchAdapter</a> functors. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="BEAST::add_slashes"></a>
std::string&nbsp;</td><td class="memItemRight" valign=bottom><b>add_slashes</b> (const std::string &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="BEAST::strip_slashes"></a>
std::string&nbsp;</td><td class="memItemRight" valign=bottom><b>strip_slashes</b> (const std::string &amp;str)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class _Iterator&gt; <a class="el" href="structBEAST_1_1extractor.html">extractor</a>&lt; _Iterator &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a2">extract</a> (_Iterator &amp;Iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs and returns an extractor of the correct type. </em> <a href="group__serialisation.html#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class _InIt, class _OutIt&gt; _InIt&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a3">copy_from</a> (_OutIt _First, _OutIt _Last, _InIt _Src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An algorithm similar to copy, but where the start and end of the target range is specified rather than the source range. </em> <a href="group__serialisation.html#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class _OutIt&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a4">copy_from_istream</a> (_OutIt _First, _OutIt _Last, std::istream &amp;in)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Although extract and copy_from should, with the help of istream_iterator, be able to fill ranges from input streams, certain difficulties with istreams arise which make the copy_from_istream function useful. </em> <a href="group__serialisation.html#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a5">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structBEAST_1_1switcher.html">switcher</a> s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input operator for the switcher helper object. </em> <a href="group__serialisation.html#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Ty, typename _Ax&gt; std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a6">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; _Ty, _Ax &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic output operator for vectors, requires the vector's contents type to have its own &lt;&lt; operator. </em> <a href="group__serialisation.html#a6"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Ty, typename _Ax&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a7">operator&gt;&gt;</a> (std::istream &amp;in, std::vector&lt; _Ty, _Ax &gt; &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic input operator for vectors, requires the vector's contents type to have its own &gt;&gt; operator. </em> <a href="group__serialisation.html#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Ty, typename _Pr, typename _Alloc&gt; std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a8">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; std::string, _Ty, _Pr, _Alloc &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A specialised output operator for maps with key type string, which uses add_slashes to encode the string. </em> <a href="group__serialisation.html#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="BEAST::operator>>"></a>
template&lt;typename _Ty, typename _Pr, typename _Alloc&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a9">operator&gt;&gt;</a> (std::istream &amp;in, const std::map&lt; std::string, _Ty, _Pr, _Alloc &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A specialised input operator for maps with key type string, which uses strip_slashes to decode the string. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Kty, typename _Ty, typename _Pr, typename _Alloc&gt; std::ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a10">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; _Kty, _Ty, _Pr, _Alloc &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic output operator for maps, requires the map's contents to have its own &lt;&lt; operator. </em> <a href="group__serialisation.html#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Kty, typename _Ty, typename _Pr, typename _Alloc&gt; std::istream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a11">operator&gt;&gt;</a> (std::istream &amp;in, std::map&lt; _Kty, _Ty, _Pr, _Alloc &gt; &amp;m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic input operator for maps, requires the map's contents to have its own &gt;&gt; operator. </em> <a href="group__serialisation.html#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T1, typename T2&gt; T1 &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__serialisation.html#a12">stream_convert</a> (T2 &amp;input)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An inline reinterpret cast which may be helpful in outputting enumeration types to streams. </em> <a href="group__serialisation.html#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="BEAST::accumulate_fun"></a>
template&lt;class _InIt, class _Ty, class _Fn1&gt; _Ty&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a12">accumulate_fun</a> (_InIt _First, _InIt _Last, _Ty _Val, _Fn1 _Func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of the STL accumulate algorithm which computes a sum of all the results of a unary function _Func applied to the values between _First and _Last. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a13" doxytag="BEAST::call_on_mem"></a>
template&lt;class T, typename M, class OP&gt; <a class="el" href="classBEAST_1_1call__on__mem__t.html">call_on_mem_t</a>&lt; T, M, OP &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a13">call_on_mem</a> (M T::*m, OP op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for constructing <a class="el" href="classBEAST_1_1call__on__mem__t.html">call_on_mem_t</a> function objects. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a14" doxytag="BEAST::bound_mem_fun"></a>
template&lt;class _Class, typename _Return, typename _Arg&gt; <a class="el" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a>&lt; _Class, _Return,<br>
 _Arg &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a14">bound_mem_fun</a> (_Class &amp;c, _Return(_Class::*memfun)(_Arg))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper function for constructing <a class="el" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a> objects. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a15" doxytag="BEAST::bound_mem_fun"></a>
template&lt;class _Class, typename _Return, typename _Arg&gt; <a class="el" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a>&lt; _Class, _Return,<br>
 _Arg &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a15">bound_mem_fun</a> (_Class *c, _Return(_Class::*memfun)(_Arg))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper function for constructing <a class="el" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a> objects. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Type, typename _Base&gt; bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a16">IsA</a> (_Base *in, _Type *&amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper for RTTI (RunTime Type Identification) typeid, which checks if two pointers are of identical types. </em> <a href="group__utilities.html#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Type, typename _Base&gt; bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a17">IsKindOf</a> (_Base *in, _Type *&amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper for RTTI (RunTime Type Identification) using dynamic_cast which checks if an object is of the same type or is in herited from an object of the same type as an input pointer. </em> <a href="group__utilities.html#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a18">bound</a> (T L, T U, T n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes a type, a lower and an upper limit and bounds the input value to those limits. </em> <a href="group__utilities.html#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a19">rbound</a> (T L, T U, T &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bound which takes a reference as its argument. </em> <a href="group__utilities.html#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a20">limit</a> (T L, T U, T n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limits the input value to the specified range, clipping at either extreme. </em> <a href="group__utilities.html#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a21">rlimit</a> (T L, T U, T &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of limit which takes a reference as its argument. </em> <a href="group__utilities.html#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a16" doxytag="BEAST::deg2rad"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a16">deg2rad</a> (double)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts degrees to radians. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a17" doxytag="BEAST::rad2deg"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a17">rad2deg</a> (double)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts radians to degrees. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a18" doxytag="BEAST::operator *"></a>
<a class="el" href="classBEAST_1_1Vector2D.html">Vector2D</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a18">operator *</a> (double l, const <a class="el" href="classBEAST_1_1Vector2D.html">Vector2D</a> &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a vector multiplied by a double. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classBEAST_1_1Vector2D.html">Vector2D</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a19">PolarVector</a> (double l, double a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classBEAST_1_1Vector2D.html">Vector2D</a> object using old PolarVector syntax. </em> <a href="group__framework.html#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a143" doxytag="BEAST::LoadPlugin"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>LoadPlugin</b> (const char *plugin, std::vector&lt; std::string &gt; &amp;names, std::vector&lt; GetSimulationBase * &gt; &amp;funcs)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a144" doxytag="BEAST::LoadPlugin"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>LoadPlugin</b> (const char *plugin, std::map&lt; std::string, GetSimulationBase * &gt; &amp;output)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a145" doxytag="BEAST::UnloadPlugin"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>UnloadPlugin</b> (const char *plugin)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a146" doxytag="BEAST::UnloadPlugins"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>UnloadPlugins</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a147" doxytag="BEAST::SetupSimulationTable"></a>
BEAST_DLL void&nbsp;</td><td class="memItemRight" valign=bottom><b>SetupSimulationTable</b> (std::vector&lt; std::string &gt; &amp;names, std::vector&lt; GetSimulationBase * &gt; &amp;funcs)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a148" doxytag="BEAST::ScreenGrab"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>ScreenGrab</b> (<a class="el" href="classBEAST_1_1World.html">World</a> &amp;theWorld, std::string filename)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;class T&gt; <a class="el" href="classBEAST_1_1Sensor.html">Sensor</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sensors.html#a11">NearestSignalSensor</a> (int highestSignal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs and returns a pointer to a sensor which will return the signal of the nearest <a class="el" href="classBEAST_1_1Signaller.html">Signaller</a> of the specified type. </em> <a href="group__sensors.html#a11"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="BEAST::ANIMAT_RADIUS"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a0">ANIMAT_RADIUS</a> = 5.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Animat's default radius. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="BEAST::ANIMAT_MAX_SPEED"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a1">ANIMAT_MAX_SPEED</a> = 100.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Animat's default maximum speed. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="BEAST::ANIMAT_MIN_SPEED"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a2">ANIMAT_MIN_SPEED</a> = -50.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Animat's default minimum speed. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a3" doxytag="BEAST::ANIMAT_MAX_ROTATE"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a3">ANIMAT_MAX_ROTATE</a> = TWOPI</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default max rotation/frame. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a4" doxytag="BEAST::ANIMAT_DRAG"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a4">ANIMAT_DRAG</a> = 50.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An arbitrary friction value. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a5" doxytag="BEAST::ANIMAT_ACCEL"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a5">ANIMAT_ACCEL</a> = 5000.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">AN arbitrary acceleration value. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a6" doxytag="BEAST::ANIMAT_TIMESTEP"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a6">ANIMAT_TIMESTEP</a> = 0.05</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default time step. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a7" doxytag="BEAST::ANIMAT_PARTS"></a>
const int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a7">ANIMAT_PARTS</a> = 4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of different colours. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a8" doxytag="BEAST::MONITOR_BARHEIGHT"></a>
const int&nbsp;</td><td class="memItemRight" valign=bottom><b>MONITOR_BARHEIGHT</b> = 25</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="BEAST::MAX_COLLISIONS"></a>
const unsigned int&nbsp;</td><td class="memItemRight" valign=bottom><b>MAX_COLLISIONS</b> = 200</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>const float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a0">ColourPalette</a> [][4]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A global colour pallete. Could probably do with many more colours. </em> <a href="group__utilities.html#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="BEAST::DRAWABLE_RADIUS"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__framework.html#a10">DRAWABLE_RADIUS</a> = 50.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default diameter for drawables. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="BEAST::FFN_ACTIVATION_RESPONSE"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a0">FFN_ACTIVATION_RESPONSE</a> = 1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This value decides the curve of the sigmoid function. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="BEAST::FFN_COLSIZE"></a>
const int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__biosystems.html#a1">FFN_COLSIZE</a> = 6</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The width of columns in ToString output. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="BEAST::SENSOR_ALPHA"></a>
const float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sensors.html#a0">SENSOR_ALPHA</a> = 0.1f</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transparency value for Sensors. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="BEAST::BEAM_SENSOR_SCOPE"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sensors.html#a1">BEAM_SENSOR_SCOPE</a> = PI/4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default scope for <a class="el" href="classBEAST_1_1BeamSensor.html">BeamSensor</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="BEAST::BEAM_SENSOR_RANGE"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sensors.html#a2">BEAM_SENSOR_RANGE</a> = 250.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default range for <a class="el" href="classBEAST_1_1BeamSensor.html">BeamSensor</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a3" doxytag="BEAST::BEAM_DRAW_QUALITY"></a>
const float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__sensors.html#a3">BEAM_DRAW_QUALITY</a> = 0.1f</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default draw quality for <a class="el" href="classBEAST_1_1BeamSensor.html">BeamSensor</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="BEAST::TRAIL_LENGTH"></a>
const unsigned int&nbsp;</td><td class="memItemRight" valign=bottom><b>TRAIL_LENGTH</b> = 30</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="BEAST::WORLD_WIDTH"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><b>WORLD_WIDTH</b> = 800.0</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a13" doxytag="BEAST::WORLD_HEIGHT"></a>
const double&nbsp;</td><td class="memItemRight" valign=bottom><b>WORLD_HEIGHT</b> = 600.0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The namespace for everything in the simulation environment. <hr><h2>Function Documentation</h2>
<a name="a96" doxytag="BEAST::add_slashes"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> string add_slashes </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>str</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Replaces spaces with underscores and adds backslashes to other characters which might be interpreted as white space by an input stream. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="namespaceBEAST.html#a97">strip_slashes</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a98" doxytag="BEAST::operator<<"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const SimObject &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [related]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An output operator for all classes derived from <a class="el" href="classBEAST_1_1SimObject.html">SimObject</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>out</em>&nbsp;</td><td>An output stream. </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>An object derived from <a class="el" href="classBEAST_1_1SimObject.html">SimObject</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to output stream. </dd></dl>
    </td>
  </tr>
</table>
<a name="a99" doxytag="BEAST::operator>>"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> istream&amp; operator&gt;&gt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">istream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>SimObject &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>obj</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [related]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An input operator for all classes derived from <a class="el" href="classBEAST_1_1SimObject.html">SimObject</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>An input stream. </td></tr>
    <tr><td valign=top><em>obj</em>&nbsp;</td><td>An object derived from <a class="el" href="classBEAST_1_1SimObject.html">SimObject</a>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to input stream. </dd></dl>
    </td>
  </tr>
</table>
<a name="a97" doxytag="BEAST::strip_slashes"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> string strip_slashes </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>str</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Removes the slashes added by add_slashes and reinstates the original string. 
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="namespaceBEAST.html#a96">add_slashes</a> </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:26:37 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
