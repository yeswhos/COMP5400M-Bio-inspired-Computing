<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: Tutorial 2: Adding Objects and Interactive Animats</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a name="tutorial2">Tutorial 2: Adding Objects and Interactive Animats</a>
</h1>In this tutorial we are going to:<ul>
<li>Add objects to the world</li><li>Make the animats interact with those objects</li><li>Hand-code a simple neural controller</li><li>Create more specialised objects with inheritance</li><li>Take a look at how sensors work</li></ul>
<p>
Some simulations need only animats to be present in the world, but sometimes it will be necessary to introduce new types of object which represent other features such as walls, food or holes in the ground. If your simulation requires the animats to have an interactive relationship with those objects, such as eating food or falling in holes, you will need to add a small amount of code which produces this response.<h2><a name="tutorial2_1"></a>
Making a Cheese Collecting Animat</h2>
For this tutorial we're going to make a new type of animat which looks for cheese. 'CheeseCollectingAnimat' is rather long, so we'll call it Mouse. Mouse's world has only two types of thing in: other mice, and cheese. Cheeses will be represented by yellow dots.<p>
We'll give Mouse a simpler sensor than Shrew had, called a NearestAngleSensor. All this tells us is the angle to the nearest object of a specified type: negative angles for objects on the left, positive angles for objects on the right and zero for objects dead ahead. Initially Mouse will have a simple hand-coded controller which orients him towards the nearest Cheese and then moves him forward, but later on we'll replace this controller with an equivalent neural network.<p>
As before we need to #include the files wxsimenv.h, <a class="el" href="animat_8h.html">animat.h</a> and <a class="el" href="sensor_8h.html">sensor.h</a>.<p>
<div class="fragment"><pre><span class="preprocessor">#include "wxsimenv.h"</span>
<span class="preprocessor">#include "<a class="code" href="animat_8h.html">animat.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="sensor_8h.html">sensor.h</a>"</span>
</pre></div><p>
Now, we'll define the Cheese class. Since cheese is just a stationary object, it can be derived from WorldObject.<p>
<div class="fragment"><pre><span class="keyword">class </span>Cheese : <span class="keyword">public</span> WorldObject
{
<span class="keyword">public</span>:
    Cheese()
    {
        This.Radius = 2.5f;                     <span class="comment">// Cheeses are quite small</span>
        This.SetColour(ColourPalette[COLOUR_YELLOW]);<span class="comment">// Cheeses are yellow</span>
        This.InitRandom = <span class="keyword">true</span>;                 <span class="comment">// Cheases are scattered</span>
    }
    <span class="keyword">virtual</span> ~Cheese(){}

    <span class="comment">// When a Cheese is Eaten, it reappears in a random location.</span>
    <span class="keywordtype">void</span> Eaten()
    {
        This.Location = myWorld-&gt;RandomLocation();
    }
};
</pre></div><p>
The constructor for Cheese sets the radius to 2.5, the colour to yellow, and the initRandom flag to true so that cheeses will be randomly scattered throughout the world. As before, Cheese bears the mandatory virtual destructor.<p>
One new method has been added, called Eaten. When a Mouse bumps into a Cheese, he will call Eaten on the cheese, which then causes the cheese to be relocated elsewhere in the world. myWorld is a pointer to whichever world the cheese is in. RandomLocation is a method of World which returns a pair of random coordinates somewhere in the boundary of the world.<p>
Now to define Mouse:<p>
<div class="fragment"><pre><span class="keyword">class </span>Mouse : <span class="keyword">public</span> Animat
{
<span class="keyword">public</span>:
    Mouse()
    {
        This.Add(<span class="stringliteral">"angle"</span>, NearestAngleSensor&lt;Cheese&gt;());
        This.InitRandom = <span class="keyword">true</span>;
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> Control()
    {
        <span class="keywordtype">double</span> o = This.Sensors[<span class="stringliteral">"angle"</span>]-&gt;GetOutput();
        This.Controls[<span class="stringliteral">"right"</span>] = 0.5 - (o &gt; 0.0 ? o : 0.0);
        This.Controls[<span class="stringliteral">"left"</span>] = 0.5 + (o &lt; 0.0 ? o : 0.0);
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnCollision(WorldObject* obj)
    {
        Cheese* cheese;

        <span class="keywordflow">if</span> (<a class="code" href="group__utilities.html#a17">IsKindOf</a>(obj,cheese)) {
            cheese-&gt;Eaten();
        }

        Animat::OnCollision(obj);
    }
};
</pre></div><p>
As before, Mouse is derived from Animat. The constructor adds just one sensor this time, the very simple NearestAngleSensor which has a range beyond the limit of the World (i.e. unlimited for our purposes), and as usual tells Mouse to start in a random place in the world.<p>
The Control method does a couple of simple calculations which give Mouse the behaviour we want: the right wheel goes at half speed plus the leftwards magnitude of the angle to the nearest cheese, the left wheel goes at half speed plus the rightwards magnitude of the angle, again something like a Braitenburg vehicle.<p>
This time the OnCollision method is also overridden. OnCollision is called on an object whenever it is involved in a collision. The argument is a pointer to the object Mouse is colliding with. Because every object in the world is derived from WorldObject, a handy feature of C++ known as polymorphism allows us to use a pointer to WorldObject to point to any object of a class derived from WorldObject. The object being passed into OnCollision might be a Cheese, or it might be another Mouse - both types of objects can be passed in, and then a test can be done to determine how Mouse acts.<p>
We don't want our mice to be cannibals so we need to test the object for cheesiness. This is done using a system known as Runtime Type Identification (RTTI), but in the simulation environment, RTTI is encapsulated into two functions: IsA and IsKindOf. Both functions take two pointers as arguments: a pointer to the object being tested and an empty pointer of the type we are testing for. Both functions return a bool - true if a match is made, false if not. IsA will only return true if the type of both pointers is exactly the same, whereas IsKindOf will return true if the object being tested is of exactly the same type, or if it's of a type derived from the type being tested. We'll look at this in more detail later.<p>
If IsA or IsKindOf return true, the test pointer which was passed in (in this case a pointer to a Cheese) will be made to point to the object which has successfully passed the test. Now that we have a Cheese pointer to the object, we can call Cheese methods on it, so Eaten is called.<p>
Finally, once the overridden OnCollision method is over, Animat's native OnCollision method still has work to do, such as stopping the Animat going through solid obstacles (other mice in this case) so Animat::OnCollision is called, passing the obj pointer through.<p>
The Simulation is set up in much the same way as before, but with two Group objects:<p>
<div class="fragment"><pre><span class="keyword">class </span>MouseSimulation : <span class="keyword">public</span> Simulation
{
    Group&lt;Mouse&gt; theMice;
    Group&lt;Cheese&gt; theCheeses;

<span class="keyword">public</span>:
    MouseSimulation():
    theMice(30)
    theCheeses(50)
    {
        This.Add(<span class="stringliteral">"Mice"</span>, theMice);
        This.Add(<span class="stringliteral">"Cheeses"</span>, theCheeses);
    }
};
</pre></div><p>
And the usual simulation table:<p>
<div class="fragment"><pre><a class="code" href="beast_8h.html#a0">BEGIN_SIMULATION_TABLE</a>
    <a class="code" href="beast_8h.html#a1">ADD_SIMULATION</a>(<span class="stringliteral">"Mice"</span>, MouseSimulation)
<a class="code" href="beast_8h.html#a2">END_SIMULATION_TABLE</a>
</pre></div><p>
Compile and run as before and you should be looking at a bunch of greedy mice.<h2><a name="tutorial2_2"></a>
Introducing Neural Controllers</h2>
Two types of Artificial Neural Network (ANN) are provided with the simulation environment: FeedForwardNet, which is a feed-forward network with one hidden layer; and DynamicalNet which is a fully-recurrant dynamical neural network. For more details on these two classes and the networks they implement, see their documentation.<p>
As a test of the FeedForwardNet class and a demonstration of one way of using it, we will code the simple controller used by the mouse into an equivalent neural network.<p>
This is what the configuration of the neural network will look like: Note that each node's output will be put through a simple threshold function, rather than the sigmoid function normally used in this type of neural network. The two weights at the input nodes ensure that if the angle is positive, one side of the network is activated, if the angle is negative the other side is activated. The bias values of -0.5 at the two output nodes ensure that each output is at least 0.5, as in the original. To adjust the mouse to use this neural network, we need to make the following code changes:<p>
The header file for FeedForwardNet needs to be included:<p>
<div class="fragment"><pre><span class="preprocessor">#include "<a class="code" href="feedforwardnet_8h.html">feedforwardnet.h</a>"</span>
</pre></div><p>
A private member must be added for the FeedForwardNet object:<p>
<div class="fragment"><pre><span class="keyword">private</span>:
    FeedForwardNet myBrain;
</pre></div><p>
The above configuration must be set up in myBrain when the Mouse is constructed. To do this, change the Mouse constructor to:<p>
<div class="fragment"><pre>Mouse():
myBrain(1, 2, 2, false)
{
    vector&lt;float&gt; ffnConfig;
    ffnConfig.push_back( 1.0f); <span class="comment">// 1st input 1st weight</span>
    ffnConfig.push_back( 0.0f); <span class="comment">// 1st input bias</span>
    ffnConfig.push_back(-1.0f); <span class="comment">// 2nd input 1st weight</span>
    ffnConfig.push_back( 0.0f); <span class="comment">// 2nd input bias</span>
    ffnConfig.push_back( 1.0f); <span class="comment">// 1st hidden 1st weight (for input 1)</span>
    ffnConfig.push_back( 0.0f); <span class="comment">// 1st hidden 2nd weight (for input 2)</span>
    ffnConfig.push_back(-0.5f); <span class="comment">// 1st hidden bias</span>
    ffnConfig.push_back( 0.0f); <span class="comment">// 2nd hidden 1st weight (for input 1)</span>
    ffnConfig.push_back( 1.0f); <span class="comment">// 2nd hidden 2nd weight (for input 2)</span>
    ffnConfig.push_back(-0.5f); <span class="comment">// 2nd hidden bias</span>

    This.myBrain.SetConfiguration(ffnConfig);

    This.Add(<span class="stringliteral">"angle"</span>, NearestAngleSensor&lt;Cheese&gt;());
    This.InitRandom = <span class="keyword">true</span>;
}
</pre></div><p>
The line myBrain(1, 2, 2, true) configures the built-in FeedForwardNet with one input, two hidden layers, two outputs and the false specifies that a simple threshold function should be used rather than the sigmoid function.<p>
The vector created in the constructor contains the values from the diagram. The FeedForwardNet’s SetConfiguration method inserts those values into the correct places in the network. This method of configuring networks is not very human-friendly, but this network wasn’t really designed to be hand-configured. However the idea of configuring the network using a fixed-length list of values is ideal for a Genetic Algorithm (surprise!) which we’ll be looking at in the next tutorial.<p>
Finally, the Mouse needs a new Control method which feeds the input from the sensor into myBrain and then sets the motors using the network’s output.<p>
<div class="fragment"><pre><span class="keyword">virtual</span> <span class="keywordtype">void</span> Control()
{
    This.myBrain.SetInput(0, sensors[<span class="stringliteral">"angle"</span>]-&gt;GetOutput());

    This.myBrain.Fire();

    This.Controls[<span class="stringliteral">"left"</span>] = This.myBrain.GetOutput(0);
    This.Controls[<span class="stringliteral">"right"</span>] = This.myBrain.GetOutput(1);
}
</pre></div><p>
Compile and run the now-brainy Mouse class and the mice should exhibit exactly the same behaviour as their non-neural predecessors. So much for neural nets, but at least we know it works!<h2><a name="tutorial2_3"></a>
Making Mice Picky</h2>
Some mice will eat anything, as long as it's cheese. Some mice prefer gruyere and won't touch anything else and some other mice won't touch the fancy stuff and stick to plain old cheese. We're going to set up this simulation now, to demonstrate the use of inheritance in constructing simulations and also the difference between IsA and IsKindOf.<p>
First, we'll create a couple of new cheeses by inheriting from the cheese base class.<p>
<div class="fragment"><pre><span class="keyword">class </span>Stilton : <span class="keyword">public</span> Cheese
{
    Stilton()
    {
        This.SetColour(0.2f, 1.0f, 0.2f);
    }
    <span class="keyword">virtual</span> ~Stilton(){}
};

<span class="keyword">class </span>Gruyere : <span class="keyword">public</span> Cheese
{
    Gruyere()
    {
        This.SetColour(1.0f, 0.5f, 0.0f);
    }
    <span class="keyword">virtual</span> ~Gruyere(){}
};
</pre></div><p>
Both of these new classes are identical to cheese except for their colour and their type. The diameter and initRandom flag are set automatically because when a class is constructed, all of its base class constructors are called automatically.<p>
Now we'll create two new kinds of mouse: <code>PickyMouse</code> and <code>OldFashionedMouse</code>.<p>
<div class="fragment"><pre><span class="keyword">class </span>PickyMouse : <span class="keyword">public</span> Mouse
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> ~PickyMouse(){}

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnCollision(WorldObject* obj)
    {
        Gruyere* cheese;

        <span class="keywordflow">if</span> (<a class="code" href="group__utilities.html#a16">IsA</a>(obj, cheese)) {
            cheese-&gt;Eaten();
        }

        This.Animat::OnCollision(obj);
    }
};

<span class="keyword">class </span>OldFashionedMouse : <span class="keyword">public</span> Mouse
{
<span class="keyword">public</span>:
    <span class="keyword">virtual</span> ~OldFashionedMouse(){}

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> OnCollision(WorldObject* obj)
    {
        Cheese* cheese;

        <span class="keywordflow">if</span> (<a class="code" href="group__utilities.html#a16">IsA</a>(obj, cheese)) {
            cheese-&gt;Eaten();
        }

        This.Animat::OnCollision(obj);
    }
};
</pre></div><p>
This time, only OnCollision needs to be overridden. In both cases IsA is used, rather than IsKindOf. Thus, even though Gruyere is a kind of cheese, OldFashionedMouse won't have anything to do with it. Either IsA or IsKindOf could have been used in the code for PickyMouse because Gruyere is the only class in the world which is a kind of Gruyere.<p>
Add four more groups to your simulation - one for each of the new classes - and adjust the numbers accordingly, then see what sort of chaos ensues! It might also help to add constructors to the different mice to set their colours so that it's clear which type is which.<h2><a name="tutorial2_4"></a>
Modifying Sensors</h2>
But... there is a problem. Your mice might know what kind of cheese they like but they have no way of recognising which is which from a distance. They all still have the same sensor which simply senses any cheese in the hierarchy, so they charge towards the nearest piece of cheese and if it's not the right kind, they just carry on charging towards it because it's still the nearest cheese.<p>
What we need to do is modify the sensor so that it detects particular types of cheese.<p>
Sensors in the simulation environment are very flexible and can be combined and mixed up in various ways. There are four elements to every sensor:<p>
<ul>
<li>A sensor class which decides which individuals in the world to look at:<ul>
<li>The basic Sensor class will consider individuals in the whole world.</li><li>AreaSensor can take on a specified shape and only looks at individuals in that area.</li><li>TouchSensor will only consider individuals touching the sensor's owner.</li><li>BeamSensor casts a ray of a certain angle scope and radius out from a particular point. A scope of 0 makes a laser which only sees dead ahead, a scope of 2 x pi (360 degrees) will detect an object within range in any direction.</li></ul>
</li><li>A matching function which decides whether or not an object is of interest to the sensor.</li><li>An evaluation function which obtains certain information about the object, e.g. how far away it is, what the angle to it is, how big it is or perhaps just keeps a count of the number of objects sensed.</li><li>A scaling function which takes the output of the evaluation function and modifies it to represent suitable output. For example, the NearestAngleSensor's scaling function takes the angle evaluator's output and scales it from the range +/- pi to +/- 1, which is easier to work with. A distance sensor usually has to scale depending on the range of the sensor and in the case of the ProximitySensor used in tutorial one, the sensor output is inverted so that smaller distances result in greater output. The scaling function might also incorporate features such as random noise to simulate real sensors.</li></ul>
<p>
Sensor functions aren't really functions at all, but instead are function objects (or functors) - classes with the parenthesis operator (or operator() ) overloaded so that an object can appear to be used as a function. For more details on how sensors work, look in the Sensors section of the documentation.<p>
So there is really no such thing as a NearestAngleSensor, it's just a bunch of function objects attached to a class. NearestAngleSensor is really a function that sets up a Sensor with the correct objects and returns a pointer to that sensor:<p>
<div class="fragment"><pre><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
Sensor* NearestAngleSensor()
{
    Sensor* s = <span class="keyword">new</span> Sensor(Vector2D(0.0, 0.0), 0.0);
    s-&gt;SetMatchingFunction(<span class="keyword">new</span> MatchKindOf&lt;T&gt;);
    s-&gt;SetEvaluationFunction(<span class="keyword">new</span> EvalNearestAngle(s, 1000.0));
    s-&gt;SetScalingFunction(<span class="keyword">new</span> ScaleLinear(-PI, PI, -1.0, 1.0));

    <span class="keywordflow">return</span> s;
}
</pre></div><p>
So to change the matching function of <code>PickyMouse</code>, simply add this line to the <code>PickyMouse</code> constructor:<p>
<div class="fragment"><pre>sensors[<span class="stringliteral">"cheese sensor"</span>]-&gt;SetMatchingFunction(<span class="keyword">new</span> MatchExact&lt;Gruyere&gt;);
</pre></div><p>
The old matching function will be deleted and a new Gruyere matcher will replace it. A similar thing can be done for the <code>OldFashionedMouse</code> <h2><a name="tutorial2_5"></a>
Things to try</h2>
<ul>
<li>Set the fourth parameter of the constructor for myBrain to true so that a sigmoid activation function is used rather than a threshold. See if you can adjust the neural net weights to compensate.</li><li>Duplicate the Eaten method of Cheese inside PickyMouse and change OldFashionedMouse so that he eats PickyMouse instead of Cheese. </li></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:26:35 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
