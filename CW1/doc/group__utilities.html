<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BEAST - Bioinspired Evolutionary Agent Simulation Toolkit: Utilities and Helper Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Utilities and Helper Functions</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>auto_indexed_pointer_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>auto_indexed_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>auto_pointer_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>auto_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A functor which creates a unary function from a unary member function, binding an instance of the class to which the function belongs. </em> <a href="structBEAST_1_1bound__mem__fun__t.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1call__on__mem__t.html">call_on_mem_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows us to bind functors so that they work on particular members of classes, useful for using for_each on maps. </em> <a href="classBEAST_1_1call__on__mem__t.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1creator.html">creator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A functor for use with the for_each algorithm which can perform creation of objects when called on a container of pointers. </em> <a href="structBEAST_1_1creator.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structBEAST_1_1deleter.html">deleter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A functor for use with the for_each algorithm which can perform deletion of objects when called on a container of pointers. </em> <a href="structBEAST_1_1deleter.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><b>pointer_property</b></td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classBEAST_1_1property.html">property</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class wrapper for a member variable which allows member data to be exposed with invisible get/set semantics. </em> <a href="classBEAST_1_1property.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="structRandom.html">Random</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function object version of randval. </em> <a href="structRandom.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a22" doxytag="Utilities::M1"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>M1</b>&nbsp;&nbsp;&nbsp;259200</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a23" doxytag="Utilities::IA1"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>IA1</b>&nbsp;&nbsp;&nbsp;7141</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a24" doxytag="Utilities::IC1"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>IC1</b>&nbsp;&nbsp;&nbsp;54773</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a25" doxytag="Utilities::RM1"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>RM1</b>&nbsp;&nbsp;&nbsp;(1.0/M1)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a26" doxytag="Utilities::M2"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>M2</b>&nbsp;&nbsp;&nbsp;134456</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a27" doxytag="Utilities::IA2"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>IA2</b>&nbsp;&nbsp;&nbsp;8121</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a28" doxytag="Utilities::IC2"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>IC2</b>&nbsp;&nbsp;&nbsp;28411</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a29" doxytag="Utilities::RM2"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>RM2</b>&nbsp;&nbsp;&nbsp;(1.0/M2)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a30" doxytag="Utilities::M3"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>M3</b>&nbsp;&nbsp;&nbsp;243000</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a31" doxytag="Utilities::IA3"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>IA3</b>&nbsp;&nbsp;&nbsp;4561</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a32" doxytag="Utilities::IC3"></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><b>IC3</b>&nbsp;&nbsp;&nbsp;51349</td></tr>

<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a33">ColourType</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__utilities.html#a33a15">COLOUR_BLACK</a>, 
<a class="el" href="group__utilities.html#a33a16">COLOUR_WHITE</a>, 
<a class="el" href="group__utilities.html#a33a17">COLOUR_GREEN</a>, 
<a class="el" href="group__utilities.html#a33a18">COLOUR_BLUE</a>, 
<br>
&nbsp;&nbsp;<b>COLOUR_RED</b>, 
<b>COLOUR_PURPLE</b>, 
<b>COLOUR_DARK_PURPLE</b>, 
<b>COLOUR_YELLOW</b>, 
<br>
&nbsp;&nbsp;<b>COLOUR_LILAC</b>, 
<b>COLOUR_BROWN</b>, 
<b>COLOUR_LIGHT_GREY</b>, 
<b>COLOUR_DARK_GREY</b>, 
<br>
&nbsp;&nbsp;<b>COLOUR_MID_GREY</b>, 
<b>COLOUR_ORANGE</b>, 
<b>COLOUR_PINK</b>, 
<b>COLOUR_SELECTION</b>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An enumeration type for colours. </em> <a href="#a33">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="Utilities::random_colour"></a>
const float *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a1">random_colour</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random colour, all set for input to glColour4fv. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="Utilities::ran1"></a>
float&nbsp;</td><td class="memItemRight" valign=bottom><b>ran1</b> (int *idum)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a3" doxytag="Utilities::rseed"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><b>rseed</b> (int *s, bool verbose)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a4" doxytag="Utilities::randval"></a>
template&lt;typename Real&gt; Real&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a4">randval</a> (Real limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a (near) uniform distributed random number in the range 0..limit, as a Real. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a5" doxytag="Utilities::irand"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a5">irand</a> (int limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random integer in [0..limit-1]. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a6" doxytag="Utilities::brand"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>brand</b> (double p)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a7" doxytag="Utilities::brand"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><b>brand</b> (float p)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a8" doxytag="Utilities::randval"></a>
template&lt;&gt; int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a8">randval</a> (int limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template specialisation to stop randval from being called with ints. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="Utilities::randval"></a>
template&lt;&gt; bool&nbsp;</td><td class="memItemRight" valign=bottom><b>randval</b> (bool)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Real&gt; Real&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a10">gaussrand</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a normally distributed variable with zero mean and unit variance. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="Utilities::normrand"></a>
template&lt;typename Real&gt; Real&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a11">normrand</a> (Real mean, Real sd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a random deviate from a normal distribution with specified mean and standard distribution. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="Utilities::accumulate_fun"></a>
template&lt;class _InIt, class _Ty, class _Fn1&gt; _Ty&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a12">accumulate_fun</a> (_InIt _First, _InIt _Last, _Ty _Val, _Fn1 _Func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of the STL accumulate algorithm which computes a sum of all the results of a unary function _Func applied to the values between _First and _Last. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a13" doxytag="Utilities::call_on_mem"></a>
template&lt;class T, typename M, class OP&gt; call_on_mem_t&lt; T, M, OP &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a13">call_on_mem</a> (M T::*m, OP op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper function for constructing <a class="el" href="classBEAST_1_1call__on__mem__t.html">call_on_mem_t</a> function objects. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a14" doxytag="Utilities::bound_mem_fun"></a>
template&lt;class _Class, typename _Return, typename _Arg&gt; bound_mem_fun_t&lt; _Class, _Return,<br>
 _Arg &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a14">bound_mem_fun</a> (_Class &amp;c, _Return(_Class::*memfun)(_Arg))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper function for constructing <a class="el" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a> objects. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a15" doxytag="Utilities::bound_mem_fun"></a>
template&lt;class _Class, typename _Return, typename _Arg&gt; bound_mem_fun_t&lt; _Class, _Return,<br>
 _Arg &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a15">bound_mem_fun</a> (_Class *c, _Return(_Class::*memfun)(_Arg))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper function for constructing <a class="el" href="structBEAST_1_1bound__mem__fun__t.html">bound_mem_fun_t</a> objects. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Type, typename _Base&gt; bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a16">IsA</a> (_Base *in, _Type *&amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper for RTTI (RunTime Type Identification) typeid, which checks if two pointers are of identical types. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename _Type, typename _Base&gt; bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a17">IsKindOf</a> (_Base *in, _Type *&amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper for RTTI (RunTime Type Identification) using dynamic_cast which checks if an object is of the same type or is in herited from an object of the same type as an input pointer. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a18">bound</a> (T L, T U, T n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes a type, a lower and an upper limit and bounds the input value to those limits. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a19">rbound</a> (T L, T U, T &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of bound which takes a reference as its argument. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; T&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a20">limit</a> (T L, T U, T n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limits the input value to the specified range, clipping at either extreme. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename T&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a21">rlimit</a> (T L, T U, T &amp;n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A version of limit which takes a reference as its argument. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>const float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__utilities.html#a0">ColourPalette</a> [][4]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A global colour pallete. Could probably do with many more colours. </em> <a href="#a0"></a><em><br><br></td></tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a name="a33" doxytag="BEAST::ColourType"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="group__utilities.html#a33">BEAST::ColourType</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An enumeration type for colours. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="a33a15" doxytag="COLOUR_BLACK"></a><em>COLOUR_BLACK</em></em>&nbsp;</td><td>
Black. </td></tr>
<tr><td valign=top><em><a name="a33a16" doxytag="COLOUR_WHITE"></a><em>COLOUR_WHITE</em></em>&nbsp;</td><td>
White. </td></tr>
<tr><td valign=top><em><a name="a33a17" doxytag="COLOUR_GREEN"></a><em>COLOUR_GREEN</em></em>&nbsp;</td><td>
Green. </td></tr>
<tr><td valign=top><em><a name="a33a18" doxytag="COLOUR_BLUE"></a><em>COLOUR_BLUE</em></em>&nbsp;</td><td>
You get the idea. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a18" doxytag="BEAST::bound"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T bound </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Takes a type, a lower and an upper limit and bounds the input value to those limits. 
<p>
Useful for angles. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>T</em>&nbsp;</td><td>The type of value. </td></tr>
    <tr><td valign=top><em>L</em>&nbsp;</td><td>The lower limit. </td></tr>
    <tr><td valign=top><em>U</em>&nbsp;</td><td>The upper limit. </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>The input value. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The output value. </dd></dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="random.h::gaussrand"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Real&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Real gaussrand </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a normally distributed variable with zero mean and unit variance. 
<p>
Recall that the absolute value will be &gt;3 about once in 400 trials (the three-sigma rule). This is adapted from the "Numerical recipies in C" book by Press, Flannery, Teukolsky, and Vetterling, p.217     </td>
  </tr>
</table>
<a name="a16" doxytag="BEAST::IsA"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename _Type, typename _Base&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bool IsA </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">_Base *&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>_Type *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A wrapper for RTTI (RunTime Type Identification) typeid, which checks if two pointers are of identical types. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A pointer to the object being tested. </td></tr>
    <tr><td valign=top><em>out</em>&nbsp;</td><td>A pointer of the type required, which will be set to point to the same object as the first parameter if it turns out they are of identical types. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if a match is made. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group__utilities.html#a17">IsKindOf</a> </dd></dl>
    </td>
  </tr>
</table>
<a name="a17" doxytag="BEAST::IsKindOf"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename _Type, typename _Base&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> bool IsKindOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">_Base *&nbsp;</td>
          <td class="mdname" nowrap> <em>in</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>_Type *&amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A wrapper for RTTI (RunTime Type Identification) using dynamic_cast which checks if an object is of the same type or is in herited from an object of the same type as an input pointer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A pointer to the object being tested. </td></tr>
    <tr><td valign=top><em>out</em>&nbsp;</td><td>A pointer of the type being tested for, which will be set to point to the same object as the first paramter if it turns out it is of the same or an inherited type. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if a match is made. </dd></dl>
    </td>
  </tr>
</table>
<a name="a20" doxytag="BEAST::limit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> T limit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Limits the input value to the specified range, clipping at either extreme. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>T</em>&nbsp;</td><td>The type of values to work on. </td></tr>
    <tr><td valign=top><em>L</em>&nbsp;</td><td>The lower limit. </td></tr>
    <tr><td valign=top><em>U</em>&nbsp;</td><td>The upper limit. </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>The input value. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The output value. </dd></dl>
    </td>
  </tr>
</table>
<a name="a19" doxytag="BEAST::rbound"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void rbound </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A version of bound which takes a reference as its argument. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>T</em>&nbsp;</td><td>The type of value. </td></tr>
    <tr><td valign=top><em>L</em>&nbsp;</td><td>The lower limit. </td></tr>
    <tr><td valign=top><em>U</em>&nbsp;</td><td>The upper limit. </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>The input value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a21" doxytag="BEAST::rlimit"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void rlimit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T&nbsp;</td>
          <td class="mdname" nowrap> <em>L</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>U</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A version of limit which takes a reference as its argument. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>T</em>&nbsp;</td><td>The type of values to work on. </td></tr>
    <tr><td valign=top><em>L</em>&nbsp;</td><td>The lower limit. </td></tr>
    <tr><td valign=top><em>U</em>&nbsp;</td><td>The upper limit. </td></tr>
    <tr><td valign=top><em>n</em>&nbsp;</td><td>The input value. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The output value. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a0" doxytag="BEAST::ColourPalette"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const float <a class="el" href="group__utilities.html#a0">BEAST::ColourPalette</a>[][4]
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><div class="fragment"><pre>
{
    {   0.0f, 0.0f, 0.0f, 1.0f  },  
    {   1.0f, 1.0f, 1.0f, 1.0f  },  
    {   0.2f, 0.8f, 0.2f, 1.0f  },  
    {   0.2f, 0.2f, 0.8f, 1.0f  },  
    {   0.8f, 0.2f, 0.2f, 1.0f  },  
    {   0.5f, 0.3f, 0.7f, 1.0f  },  
    {   0.2f, 0.0f, 0.4f, 1.0f  },  
    {   0.8f, 0.8f, 0.2f, 1.0f  },  
    {   0.8f, 0.5f, 0.9f, 1.0f  },  
    {   0.4f, 0.3f, 0.1f, 1.0f  },  
    {   0.8f, 0.8f, 0.8f, 1.0f  },  
    {   0.3f, 0.3f, 0.3f, 1.0f  },  
    {   0.5f, 0.5f, 0.5f, 1.0f  },  
    {   0.9f, 0.9f, 0.1f, 1.0f  },  
    {   1.0f, 0.8f, 0.8f, 1.0f  },  
    {   0.5f, 0.5f, 1.0f, 0.5f  }   
}
</pre></div>A global colour pallete. Could probably do with many more colours. 
<p>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun Feb 1 21:26:37 2004 for BEAST - Bioinspired Evolutionary Agent Simulation Toolkit by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
